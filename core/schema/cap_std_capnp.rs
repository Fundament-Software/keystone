// @generated by the capnpc-rust plugin to the Cap'n Proto schema compiler.
// DO NOT EDIT.
// source: F:/code/keystone/core/schema/cap_std.capnp



pub mod file {
  #![allow(unused_variables)]
  pub type SyncAllParams<> = ::capnp::capability::Params<crate::cap_std_capnp::file::sync_all_params::Owned>;
  pub type SyncAllResults<> = ::capnp::capability::Results<crate::cap_std_capnp::file::sync_all_results::Owned>;
  pub type SyncDataParams<> = ::capnp::capability::Params<crate::cap_std_capnp::file::sync_data_params::Owned>;
  pub type SyncDataResults<> = ::capnp::capability::Results<crate::cap_std_capnp::file::sync_data_results::Owned>;
  pub type SetLenParams<> = ::capnp::capability::Params<crate::cap_std_capnp::file::set_len_params::Owned>;
  pub type SetLenResults<> = ::capnp::capability::Results<crate::cap_std_capnp::file::set_len_results::Owned>;
  pub type MetadataParams<> = ::capnp::capability::Params<crate::cap_std_capnp::file::metadata_params::Owned>;
  pub type MetadataResults<> = ::capnp::capability::Results<crate::cap_std_capnp::file::metadata_results::Owned>;
  pub type TryCloneParams<> = ::capnp::capability::Params<crate::cap_std_capnp::file::try_clone_params::Owned>;
  pub type TryCloneResults<> = ::capnp::capability::Results<crate::cap_std_capnp::file::try_clone_results::Owned>;
  pub type SetReadonlyParams<> = ::capnp::capability::Params<crate::cap_std_capnp::file::set_readonly_params::Owned>;
  pub type SetReadonlyResults<> = ::capnp::capability::Results<crate::cap_std_capnp::file::set_readonly_results::Owned>;
  pub type OpenParams<> = ::capnp::capability::Params<crate::cap_std_capnp::file::open_params::Owned>;
  pub type OpenResults<> = ::capnp::capability::Results<crate::cap_std_capnp::file::open_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn sync_all_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::file::sync_all_params::Owned,crate::cap_std_capnp::file::sync_all_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn sync_data_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::file::sync_data_params::Owned,crate::cap_std_capnp::file::sync_data_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
    pub fn set_len_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::file::set_len_params::Owned,crate::cap_std_capnp::file::set_len_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 2, ::core::option::Option::None)
    }
    pub fn metadata_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::file::metadata_params::Owned,crate::cap_std_capnp::file::metadata_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 3, ::core::option::Option::None)
    }
    pub fn try_clone_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::file::try_clone_params::Owned,crate::cap_std_capnp::file::try_clone_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 4, ::core::option::Option::None)
    }
    pub fn set_readonly_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::file::set_readonly_params::Owned,crate::cap_std_capnp::file::set_readonly_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 5, ::core::option::Option::None)
    }
    pub fn open_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::file::open_params::Owned,crate::cap_std_capnp::file::open_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 6, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn sync_all(&self, _: SyncAllParams<>, _: SyncAllResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method file::Server::sync_all not implemented".to_string())) }
    async fn sync_data(&self, _: SyncDataParams<>, _: SyncDataResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method file::Server::sync_data not implemented".to_string())) }
    async fn set_len(&self, _: SetLenParams<>, _: SetLenResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method file::Server::set_len not implemented".to_string())) }
    async fn metadata(&self, _: MetadataParams<>, _: MetadataResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method file::Server::metadata not implemented".to_string())) }
    async fn try_clone(&self, _: TryCloneParams<>, _: TryCloneResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method file::Server::try_clone not implemented".to_string())) }
    async fn set_readonly(&self, _: SetReadonlyParams<>, _: SetReadonlyResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method file::Server::set_readonly not implemented".to_string())) }
    async fn open(&self, _: OpenParams<>, _: OpenResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method file::Server::open not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.sync_all(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.sync_data(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          2 => server.set_len(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          3 => server.metadata(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          4 => server.try_clone(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          5 => server.set_readonly(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          6 => server.open(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xff9a_b96b_3e36_55c2;
    pub static ENCODED_NODE: [::capnp::Word; 95] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 130, 1, 0, 0),
      ::capnp::word(41, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(37, 0, 0, 0, 199, 1, 0, 0),
      ::capnp::word(77, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 70, 105, 108, 101, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(28, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(156, 126, 221, 104, 125, 73, 166, 208),
      ::capnp::word(111, 10, 29, 125, 218, 91, 212, 148),
      ::capnp::word(209, 0, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(197, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(195, 60, 68, 206, 203, 30, 115, 242),
      ::capnp::word(210, 40, 25, 1, 233, 69, 47, 237),
      ::capnp::word(185, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(177, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(185, 208, 190, 224, 70, 110, 227, 143),
      ::capnp::word(56, 100, 74, 247, 119, 158, 170, 227),
      ::capnp::word(165, 0, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(153, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(68, 11, 251, 58, 16, 4, 209, 223),
      ::capnp::word(240, 192, 0, 212, 0, 177, 142, 236),
      ::capnp::word(141, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(133, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(208, 91, 250, 122, 205, 159, 13, 242),
      ::capnp::word(106, 126, 141, 171, 27, 164, 133, 245),
      ::capnp::word(121, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(113, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(221, 138, 76, 195, 6, 58, 214, 149),
      ::capnp::word(211, 114, 199, 15, 149, 65, 157, 227),
      ::capnp::word(101, 0, 0, 0, 98, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(93, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(150, 76, 154, 144, 245, 237, 188, 173),
      ::capnp::word(112, 88, 4, 139, 143, 107, 189, 246),
      ::capnp::word(81, 0, 0, 0, 42, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(69, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(115, 121, 110, 99, 65, 108, 108, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 121, 110, 99, 68, 97, 116, 97),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 101, 116, 76, 101, 110, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(116, 114, 121, 67, 108, 111, 110, 101),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 101, 116, 82, 101, 97, 100, 111),
      ::capnp::word(110, 108, 121, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(111, 112, 101, 110, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod sync_all_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(156, 126, 221, 104, 125, 73, 166, 208),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(115, 121, 110, 99, 65, 108, 108, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd0a6_497d_68dd_7e9c;
    }
  }

  pub mod sync_all_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(111, 10, 29, 125, 218, 91, 212, 148),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(115, 121, 110, 99, 65, 108, 108, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x94d4_5bda_7d1d_0a6f;
    }
  }

  pub mod sync_data_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(195, 60, 68, 206, 203, 30, 115, 242),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(115, 121, 110, 99, 68, 97, 116, 97),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf273_1ecb_ce44_3cc3;
    }
  }

  pub mod sync_data_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(210, 40, 25, 1, 233, 69, 47, 237),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(115, 121, 110, 99, 68, 97, 116, 97),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xed2f_45e9_0119_28d2;
    }
  }

  pub mod set_len_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_size(self) -> u64 {
        self.reader.get_data_field::<u64>(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_size(self) -> u64 {
        self.builder.get_data_field::<u64>(0)
      }
      #[inline]
      pub fn set_size(&mut self, value: u64)  {
        self.builder.set_data_field::<u64>(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(185, 208, 190, 224, 70, 110, 227, 143),
        ::capnp::word(48, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 242, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(115, 101, 116, 76, 101, 110, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(115, 105, 122, 101, 0, 0, 0, 0),
        ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <u64 as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8fe3_6e46_e0be_d0b9;
    }
  }

  pub mod set_len_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(56, 100, 74, 247, 119, 158, 170, 227),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(115, 101, 116, 76, 101, 110, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe3aa_9e77_f74a_6438;
    }
  }

  pub mod metadata_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(68, 11, 251, 58, 16, 4, 209, 223),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xdfd1_0410_3afb_0b44;
    }
  }

  pub mod metadata_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_metadata(&mut self, value: crate::cap_std_capnp::metadata::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_metadata(&self) -> crate::cap_std_capnp::metadata::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(240, 192, 0, 212, 0, 177, 142, 236),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 146, 247, 39, 247, 32, 193, 202),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::metadata::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xec8e_b100_d400_c0f0;
    }
  }

  pub mod try_clone_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(208, 91, 250, 122, 205, 159, 13, 242),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(116, 114, 121, 67, 108, 111, 110, 101),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf20d_9fcd_7afa_5bd0;
    }
  }

  pub mod try_clone_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_cloned(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_cloned(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_cloned(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_cloned(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_cloned(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_cloned(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(106, 126, 141, 171, 27, 164, 133, 245),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(116, 114, 121, 67, 108, 111, 110, 101),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(99, 108, 111, 110, 101, 100, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf585_a41b_ab8d_7e6a;
    }
  }

  pub mod set_readonly_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_readonly(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_readonly(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_readonly(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(221, 138, 76, 195, 6, 58, 214, 149),
        ::capnp::word(48, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(115, 101, 116, 82, 101, 97, 100, 111),
        ::capnp::word(110, 108, 121, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 97, 100, 111, 110, 108, 121),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x95d6_3a06_c34c_8add;
    }
  }

  pub mod set_readonly_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(211, 114, 199, 15, 149, 65, 157, 227),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(115, 101, 116, 82, 101, 97, 100, 111),
        ::capnp::word(110, 108, 121, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe39d_4195_0fc7_72d3;
    }
  }

  pub mod open_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(150, 76, 154, 144, 245, 237, 188, 173),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 226, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(111, 112, 101, 110, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xadbc_edf5_909a_4c96;
    }
  }

  pub mod open_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_stream(self) -> ::capnp::Result<crate::byte_stream_capnp::byte_stream::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_stream(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_stream(self) -> ::capnp::Result<crate::byte_stream_capnp::byte_stream::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_stream(&mut self, value: crate::byte_stream_capnp::byte_stream::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_stream(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_stream(&self) -> crate::byte_stream_capnp::byte_stream::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(112, 88, 4, 139, 143, 107, 189, 246),
        ::capnp::word(48, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 234, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 70, 105, 108, 101, 46),
        ::capnp::word(111, 112, 101, 110, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(115, 116, 114, 101, 97, 109, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(102, 151, 10, 220, 160, 216, 231, 210),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::byte_stream_capnp::byte_stream::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf6bd_6b8f_8b04_5870;
    }
  }
}


pub mod dir {
  #![allow(unused_variables)]
  pub type OpenParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::open_params::Owned>;
  pub type OpenResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::open_results::Owned>;
  pub type OpenWithParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::open_with_params::Owned>;
  pub type OpenWithResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::open_with_results::Owned>;
  pub type CreateDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::create_dir_params::Owned>;
  pub type CreateDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::create_dir_results::Owned>;
  pub type CreateDirAllParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::create_dir_all_params::Owned>;
  pub type CreateDirAllResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::create_dir_all_results::Owned>;
  pub type CreateParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::create_params::Owned>;
  pub type CreateResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::create_results::Owned>;
  pub type CanonicalizeParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::canonicalize_params::Owned>;
  pub type CanonicalizeResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::canonicalize_results::Owned>;
  pub type CopyParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::copy_params::Owned>;
  pub type CopyResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::copy_results::Owned>;
  pub type HardLinkParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::hard_link_params::Owned>;
  pub type HardLinkResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::hard_link_results::Owned>;
  pub type MetadataParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::metadata_params::Owned>;
  pub type MetadataResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::metadata_results::Owned>;
  pub type DirMetadataParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::dir_metadata_params::Owned>;
  pub type DirMetadataResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::dir_metadata_results::Owned>;
  pub type EntriesParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::entries_params::Owned>;
  pub type EntriesResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::entries_results::Owned>;
  pub type ReadDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::read_dir_params::Owned>;
  pub type ReadDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::read_dir_results::Owned>;
  pub type ReadParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::read_params::Owned>;
  pub type ReadResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::read_results::Owned>;
  pub type ReadLinkParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::read_link_params::Owned>;
  pub type ReadLinkResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::read_link_results::Owned>;
  pub type ReadToStringParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::read_to_string_params::Owned>;
  pub type ReadToStringResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::read_to_string_results::Owned>;
  pub type RemoveDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::remove_dir_params::Owned>;
  pub type RemoveDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::remove_dir_results::Owned>;
  pub type RemoveDirAllParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::remove_dir_all_params::Owned>;
  pub type RemoveDirAllResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::remove_dir_all_results::Owned>;
  pub type RemoveOpenDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::remove_open_dir_params::Owned>;
  pub type RemoveOpenDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::remove_open_dir_results::Owned>;
  pub type RemoveOpenDirAllParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::remove_open_dir_all_params::Owned>;
  pub type RemoveOpenDirAllResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::remove_open_dir_all_results::Owned>;
  pub type RemoveFileParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::remove_file_params::Owned>;
  pub type RemoveFileResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::remove_file_results::Owned>;
  pub type RenameParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::rename_params::Owned>;
  pub type RenameResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::rename_results::Owned>;
  pub type SetReadonlyParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::set_readonly_params::Owned>;
  pub type SetReadonlyResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::set_readonly_results::Owned>;
  pub type SymlinkMetadataParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::symlink_metadata_params::Owned>;
  pub type SymlinkMetadataResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::symlink_metadata_results::Owned>;
  pub type WriteParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::write_params::Owned>;
  pub type WriteResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::write_results::Owned>;
  pub type SymlinkParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::symlink_params::Owned>;
  pub type SymlinkResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::symlink_results::Owned>;
  pub type ExistsParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::exists_params::Owned>;
  pub type ExistsResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::exists_results::Owned>;
  pub type TryExistsParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::try_exists_params::Owned>;
  pub type TryExistsResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::try_exists_results::Owned>;
  pub type IsFileParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::is_file_params::Owned>;
  pub type IsFileResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::is_file_results::Owned>;
  pub type IsDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::is_dir_params::Owned>;
  pub type IsDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::is_dir_results::Owned>;
  pub type TempDirNewInParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::temp_dir_new_in_params::Owned>;
  pub type TempDirNewInResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::temp_dir_new_in_results::Owned>;
  pub type TempFileNewParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::temp_file_new_params::Owned>;
  pub type TempFileNewResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::temp_file_new_results::Owned>;
  pub type TempFileNewAnonymousParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir::temp_file_new_anonymous_params::Owned>;
  pub type TempFileNewAnonymousResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir::temp_file_new_anonymous_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn open_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::open_params::Owned,crate::cap_std_capnp::dir::open_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn open_with_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::open_with_params::Owned,crate::cap_std_capnp::dir::open_with_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
    pub fn create_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::create_dir_params::Owned,crate::cap_std_capnp::dir::create_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 2, ::core::option::Option::None)
    }
    pub fn create_dir_all_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::create_dir_all_params::Owned,crate::cap_std_capnp::dir::create_dir_all_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 3, ::core::option::Option::None)
    }
    pub fn create_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::create_params::Owned,crate::cap_std_capnp::dir::create_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 4, ::core::option::Option::None)
    }
    pub fn canonicalize_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::canonicalize_params::Owned,crate::cap_std_capnp::dir::canonicalize_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 5, ::core::option::Option::None)
    }
    pub fn copy_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::copy_params::Owned,crate::cap_std_capnp::dir::copy_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 6, ::core::option::Option::None)
    }
    pub fn hard_link_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::hard_link_params::Owned,crate::cap_std_capnp::dir::hard_link_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 7, ::core::option::Option::None)
    }
    pub fn metadata_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::metadata_params::Owned,crate::cap_std_capnp::dir::metadata_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 8, ::core::option::Option::None)
    }
    pub fn dir_metadata_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::dir_metadata_params::Owned,crate::cap_std_capnp::dir::dir_metadata_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 9, ::core::option::Option::None)
    }
    pub fn entries_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::entries_params::Owned,crate::cap_std_capnp::dir::entries_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 10, ::core::option::Option::None)
    }
    pub fn read_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::read_dir_params::Owned,crate::cap_std_capnp::dir::read_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 11, ::core::option::Option::None)
    }
    pub fn read_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::read_params::Owned,crate::cap_std_capnp::dir::read_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 12, ::core::option::Option::None)
    }
    pub fn read_link_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::read_link_params::Owned,crate::cap_std_capnp::dir::read_link_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 13, ::core::option::Option::None)
    }
    pub fn read_to_string_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::read_to_string_params::Owned,crate::cap_std_capnp::dir::read_to_string_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 14, ::core::option::Option::None)
    }
    pub fn remove_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::remove_dir_params::Owned,crate::cap_std_capnp::dir::remove_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 15, ::core::option::Option::None)
    }
    pub fn remove_dir_all_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::remove_dir_all_params::Owned,crate::cap_std_capnp::dir::remove_dir_all_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 16, ::core::option::Option::None)
    }
    pub fn remove_open_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::remove_open_dir_params::Owned,crate::cap_std_capnp::dir::remove_open_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 17, ::core::option::Option::None)
    }
    pub fn remove_open_dir_all_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::remove_open_dir_all_params::Owned,crate::cap_std_capnp::dir::remove_open_dir_all_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 18, ::core::option::Option::None)
    }
    pub fn remove_file_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::remove_file_params::Owned,crate::cap_std_capnp::dir::remove_file_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 19, ::core::option::Option::None)
    }
    pub fn rename_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::rename_params::Owned,crate::cap_std_capnp::dir::rename_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 20, ::core::option::Option::None)
    }
    pub fn set_readonly_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::set_readonly_params::Owned,crate::cap_std_capnp::dir::set_readonly_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 21, ::core::option::Option::None)
    }
    pub fn symlink_metadata_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::symlink_metadata_params::Owned,crate::cap_std_capnp::dir::symlink_metadata_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 22, ::core::option::Option::None)
    }
    pub fn write_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::write_params::Owned,crate::cap_std_capnp::dir::write_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 23, ::core::option::Option::None)
    }
    pub fn symlink_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::symlink_params::Owned,crate::cap_std_capnp::dir::symlink_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 24, ::core::option::Option::None)
    }
    pub fn exists_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::exists_params::Owned,crate::cap_std_capnp::dir::exists_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 25, ::core::option::Option::None)
    }
    pub fn try_exists_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::try_exists_params::Owned,crate::cap_std_capnp::dir::try_exists_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 26, ::core::option::Option::None)
    }
    pub fn is_file_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::is_file_params::Owned,crate::cap_std_capnp::dir::is_file_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 27, ::core::option::Option::None)
    }
    pub fn is_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::is_dir_params::Owned,crate::cap_std_capnp::dir::is_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 28, ::core::option::Option::None)
    }
    pub fn temp_dir_new_in_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::temp_dir_new_in_params::Owned,crate::cap_std_capnp::dir::temp_dir_new_in_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 29, ::core::option::Option::None)
    }
    pub fn temp_file_new_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::temp_file_new_params::Owned,crate::cap_std_capnp::dir::temp_file_new_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 30, ::core::option::Option::None)
    }
    pub fn temp_file_new_anonymous_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir::temp_file_new_anonymous_params::Owned,crate::cap_std_capnp::dir::temp_file_new_anonymous_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 31, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn open(&self, _: OpenParams<>, _: OpenResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::open not implemented".to_string())) }
    async fn open_with(&self, _: OpenWithParams<>, _: OpenWithResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::open_with not implemented".to_string())) }
    async fn create_dir(&self, _: CreateDirParams<>, _: CreateDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::create_dir not implemented".to_string())) }
    async fn create_dir_all(&self, _: CreateDirAllParams<>, _: CreateDirAllResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::create_dir_all not implemented".to_string())) }
    async fn create(&self, _: CreateParams<>, _: CreateResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::create not implemented".to_string())) }
    async fn canonicalize(&self, _: CanonicalizeParams<>, _: CanonicalizeResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::canonicalize not implemented".to_string())) }
    async fn copy(&self, _: CopyParams<>, _: CopyResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::copy not implemented".to_string())) }
    async fn hard_link(&self, _: HardLinkParams<>, _: HardLinkResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::hard_link not implemented".to_string())) }
    async fn metadata(&self, _: MetadataParams<>, _: MetadataResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::metadata not implemented".to_string())) }
    async fn dir_metadata(&self, _: DirMetadataParams<>, _: DirMetadataResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::dir_metadata not implemented".to_string())) }
    async fn entries(&self, _: EntriesParams<>, _: EntriesResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::entries not implemented".to_string())) }
    async fn read_dir(&self, _: ReadDirParams<>, _: ReadDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::read_dir not implemented".to_string())) }
    async fn read(&self, _: ReadParams<>, _: ReadResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::read not implemented".to_string())) }
    async fn read_link(&self, _: ReadLinkParams<>, _: ReadLinkResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::read_link not implemented".to_string())) }
    async fn read_to_string(&self, _: ReadToStringParams<>, _: ReadToStringResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::read_to_string not implemented".to_string())) }
    async fn remove_dir(&self, _: RemoveDirParams<>, _: RemoveDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::remove_dir not implemented".to_string())) }
    async fn remove_dir_all(&self, _: RemoveDirAllParams<>, _: RemoveDirAllResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::remove_dir_all not implemented".to_string())) }
    async fn remove_open_dir(&self, _: RemoveOpenDirParams<>, _: RemoveOpenDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::remove_open_dir not implemented".to_string())) }
    async fn remove_open_dir_all(&self, _: RemoveOpenDirAllParams<>, _: RemoveOpenDirAllResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::remove_open_dir_all not implemented".to_string())) }
    async fn remove_file(&self, _: RemoveFileParams<>, _: RemoveFileResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::remove_file not implemented".to_string())) }
    async fn rename(&self, _: RenameParams<>, _: RenameResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::rename not implemented".to_string())) }
    async fn set_readonly(&self, _: SetReadonlyParams<>, _: SetReadonlyResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::set_readonly not implemented".to_string())) }
    async fn symlink_metadata(&self, _: SymlinkMetadataParams<>, _: SymlinkMetadataResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::symlink_metadata not implemented".to_string())) }
    async fn write(&self, _: WriteParams<>, _: WriteResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::write not implemented".to_string())) }
    async fn symlink(&self, _: SymlinkParams<>, _: SymlinkResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::symlink not implemented".to_string())) }
    async fn exists(&self, _: ExistsParams<>, _: ExistsResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::exists not implemented".to_string())) }
    async fn try_exists(&self, _: TryExistsParams<>, _: TryExistsResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::try_exists not implemented".to_string())) }
    async fn is_file(&self, _: IsFileParams<>, _: IsFileResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::is_file not implemented".to_string())) }
    async fn is_dir(&self, _: IsDirParams<>, _: IsDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::is_dir not implemented".to_string())) }
    async fn temp_dir_new_in(&self, _: TempDirNewInParams<>, _: TempDirNewInResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::temp_dir_new_in not implemented".to_string())) }
    async fn temp_file_new(&self, _: TempFileNewParams<>, _: TempFileNewResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::temp_file_new not implemented".to_string())) }
    async fn temp_file_new_anonymous(&self, _: TempFileNewAnonymousParams<>, _: TempFileNewAnonymousResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir::Server::temp_file_new_anonymous not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.open(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.open_with(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          2 => server.create_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          3 => server.create_dir_all(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          4 => server.create(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          5 => server.canonicalize(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          6 => server.copy(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          7 => server.hard_link(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          8 => server.metadata(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          9 => server.dir_metadata(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          10 => server.entries(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          11 => server.read_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          12 => server.read(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          13 => server.read_link(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          14 => server.read_to_string(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          15 => server.remove_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          16 => server.remove_dir_all(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          17 => server.remove_open_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          18 => server.remove_open_dir_all(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          19 => server.remove_file(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          20 => server.rename(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          21 => server.set_readonly(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          22 => server.symlink_metadata(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          23 => server.write(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          24 => server.symlink(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          25 => server.exists(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          26 => server.try_exists(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          27 => server.is_file(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          28 => server.is_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          29 => server.temp_dir_new_in(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          30 => server.temp_file_new(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          31 => server.temp_file_new_anonymous(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xa274_7d66_b9b9_2101;
    pub static ENCODED_NODE: [::capnp::Word; 363] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 122, 1, 0, 0),
      ::capnp::word(41, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(37, 0, 0, 0, 7, 8, 0, 0),
      ::capnp::word(125, 5, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 68, 105, 114, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(128, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(76, 255, 167, 50, 253, 214, 68, 193),
      ::capnp::word(197, 248, 7, 73, 82, 184, 34, 186),
      ::capnp::word(241, 3, 0, 0, 42, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(229, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(62, 233, 64, 78, 25, 127, 137, 204),
      ::capnp::word(183, 62, 188, 184, 30, 208, 145, 186),
      ::capnp::word(217, 3, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(209, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(143, 219, 63, 155, 61, 237, 107, 132),
      ::capnp::word(5, 177, 160, 110, 21, 175, 148, 143),
      ::capnp::word(197, 3, 0, 0, 82, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(189, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(10, 88, 102, 86, 29, 10, 21, 250),
      ::capnp::word(172, 30, 193, 11, 19, 220, 187, 176),
      ::capnp::word(177, 3, 0, 0, 106, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(169, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(171, 91, 125, 130, 108, 228, 77, 226),
      ::capnp::word(208, 13, 245, 143, 141, 149, 224, 230),
      ::capnp::word(157, 3, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(145, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(4, 61, 224, 238, 232, 163, 130, 253),
      ::capnp::word(212, 225, 174, 117, 43, 210, 107, 183),
      ::capnp::word(133, 3, 0, 0, 106, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(125, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(40, 52, 108, 238, 39, 5, 70, 185),
      ::capnp::word(79, 9, 187, 111, 5, 230, 197, 188),
      ::capnp::word(113, 3, 0, 0, 42, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(101, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(208, 106, 218, 80, 105, 28, 54, 248),
      ::capnp::word(215, 68, 233, 189, 218, 25, 114, 184),
      ::capnp::word(89, 3, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(81, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(247, 135, 185, 163, 73, 243, 65, 144),
      ::capnp::word(236, 48, 45, 47, 27, 45, 236, 169),
      ::capnp::word(69, 3, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(61, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(32, 14, 160, 74, 12, 195, 237, 244),
      ::capnp::word(245, 203, 145, 154, 208, 172, 43, 162),
      ::capnp::word(49, 3, 0, 0, 98, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(10, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(124, 61, 65, 251, 8, 180, 234, 196),
      ::capnp::word(209, 222, 55, 117, 155, 233, 129, 171),
      ::capnp::word(29, 3, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(17, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(11, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(139, 129, 64, 245, 135, 89, 85, 241),
      ::capnp::word(145, 220, 174, 198, 225, 88, 85, 210),
      ::capnp::word(5, 3, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(249, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(224, 39, 229, 137, 250, 24, 146, 130),
      ::capnp::word(5, 79, 169, 224, 202, 240, 160, 130),
      ::capnp::word(237, 2, 0, 0, 42, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(225, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(33, 168, 118, 101, 254, 230, 77, 227),
      ::capnp::word(103, 27, 222, 121, 206, 234, 238, 164),
      ::capnp::word(213, 2, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(205, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(14, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(65, 5, 41, 103, 82, 62, 185, 219),
      ::capnp::word(75, 167, 223, 168, 24, 95, 153, 208),
      ::capnp::word(193, 2, 0, 0, 106, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(185, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(15, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(157, 212, 90, 123, 246, 47, 11, 248),
      ::capnp::word(130, 254, 92, 38, 193, 29, 111, 194),
      ::capnp::word(173, 2, 0, 0, 82, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(165, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(46, 241, 218, 64, 105, 45, 161, 171),
      ::capnp::word(159, 199, 162, 38, 201, 33, 242, 225),
      ::capnp::word(153, 2, 0, 0, 106, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(145, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(164, 24, 104, 26, 182, 157, 12, 188),
      ::capnp::word(165, 68, 252, 125, 146, 247, 198, 224),
      ::capnp::word(133, 2, 0, 0, 114, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(125, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(18, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(184, 220, 24, 132, 74, 105, 111, 173),
      ::capnp::word(207, 17, 78, 176, 158, 47, 71, 148),
      ::capnp::word(113, 2, 0, 0, 138, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(109, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(19, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(225, 90, 36, 241, 131, 101, 41, 169),
      ::capnp::word(195, 116, 190, 226, 106, 18, 0, 198),
      ::capnp::word(97, 2, 0, 0, 90, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(89, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(20, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(92, 85, 112, 46, 189, 121, 35, 192),
      ::capnp::word(121, 110, 155, 213, 248, 63, 73, 143),
      ::capnp::word(77, 2, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(65, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(50, 86, 12, 158, 205, 29, 57, 214),
      ::capnp::word(4, 91, 151, 195, 2, 34, 109, 221),
      ::capnp::word(53, 2, 0, 0, 98, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(45, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(22, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(111, 90, 118, 79, 145, 231, 240, 212),
      ::capnp::word(6, 11, 120, 152, 119, 237, 208, 151),
      ::capnp::word(33, 2, 0, 0, 130, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(25, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(23, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(212, 237, 80, 225, 141, 71, 252, 191),
      ::capnp::word(78, 224, 170, 227, 38, 175, 162, 216),
      ::capnp::word(13, 2, 0, 0, 50, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(24, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(112, 188, 48, 22, 25, 245, 220, 178),
      ::capnp::word(214, 20, 35, 65, 0, 232, 128, 244),
      ::capnp::word(245, 1, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(233, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(25, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(28, 218, 166, 84, 184, 124, 83, 197),
      ::capnp::word(68, 47, 92, 164, 204, 255, 182, 252),
      ::capnp::word(221, 1, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(209, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(26, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(214, 56, 241, 14, 25, 130, 80, 185),
      ::capnp::word(152, 185, 188, 100, 168, 166, 121, 235),
      ::capnp::word(197, 1, 0, 0, 82, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(189, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(27, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(186, 209, 56, 106, 128, 122, 134, 146),
      ::capnp::word(145, 235, 225, 213, 140, 0, 108, 235),
      ::capnp::word(177, 1, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(165, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(28, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(116, 126, 18, 54, 219, 227, 105, 255),
      ::capnp::word(147, 130, 229, 124, 116, 151, 149, 148),
      ::capnp::word(153, 1, 0, 0, 50, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(141, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(29, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(63, 34, 41, 36, 125, 84, 135, 159),
      ::capnp::word(126, 144, 59, 57, 94, 177, 244, 212),
      ::capnp::word(129, 1, 0, 0, 106, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(121, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(30, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(119, 217, 162, 212, 56, 190, 179, 163),
      ::capnp::word(110, 182, 61, 209, 147, 41, 189, 136),
      ::capnp::word(109, 1, 0, 0, 98, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(101, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(31, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(14, 188, 165, 206, 103, 63, 38, 245),
      ::capnp::word(117, 172, 171, 182, 107, 12, 200, 235),
      ::capnp::word(89, 1, 0, 0, 170, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(85, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(111, 112, 101, 110, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(111, 112, 101, 110, 87, 105, 116, 104),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 114, 101, 97, 116, 101, 68, 105),
      ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 114, 101, 97, 116, 101, 68, 105),
      ::capnp::word(114, 65, 108, 108, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 114, 101, 97, 116, 101, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 97, 110, 111, 110, 105, 99, 97),
      ::capnp::word(108, 105, 122, 101, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 111, 112, 121, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(104, 97, 114, 100, 76, 105, 110, 107),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(100, 105, 114, 77, 101, 116, 97, 100),
      ::capnp::word(97, 116, 97, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(101, 110, 116, 114, 105, 101, 115, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 97, 100, 68, 105, 114, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 97, 100, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 97, 100, 76, 105, 110, 107),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 97, 100, 84, 111, 83, 116),
      ::capnp::word(114, 105, 110, 103, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 109, 111, 118, 101, 68, 105),
      ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 109, 111, 118, 101, 68, 105),
      ::capnp::word(114, 65, 108, 108, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 109, 111, 118, 101, 79, 112),
      ::capnp::word(101, 110, 68, 105, 114, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 109, 111, 118, 101, 79, 112),
      ::capnp::word(101, 110, 68, 105, 114, 65, 108, 108),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 109, 111, 118, 101, 70, 105),
      ::capnp::word(108, 101, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 110, 97, 109, 101, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 101, 116, 82, 101, 97, 100, 111),
      ::capnp::word(110, 108, 121, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 121, 109, 108, 105, 110, 107, 77),
      ::capnp::word(101, 116, 97, 100, 97, 116, 97, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(119, 114, 105, 116, 101, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 121, 109, 108, 105, 110, 107, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(101, 120, 105, 115, 116, 115, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(116, 114, 121, 69, 120, 105, 115, 116),
      ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(105, 115, 70, 105, 108, 101, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(105, 115, 68, 105, 114, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(116, 101, 109, 112, 68, 105, 114, 78),
      ::capnp::word(101, 119, 73, 110, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(116, 101, 109, 112, 70, 105, 108, 101),
      ::capnp::word(78, 101, 119, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(116, 101, 109, 112, 70, 105, 108, 101),
      ::capnp::word(78, 101, 119, 65, 110, 111, 110, 121),
      ::capnp::word(109, 111, 117, 115, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod open_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(76, 255, 167, 50, 253, 214, 68, 193),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 218, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 111),
        ::capnp::word(112, 101, 110, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc144_d6fd_32a7_ff4c;
    }
  }

  pub mod open_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(197, 248, 7, 73, 82, 184, 34, 186),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 226, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 111),
        ::capnp::word(112, 101, 110, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xba22_b852_4907_f8c5;
    }
  }

  pub mod open_with_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_open_options(self) -> ::capnp::Result<crate::cap_std_capnp::open_options::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_open_options(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 2 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_open_options(self) -> ::capnp::Result<crate::cap_std_capnp::open_options::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_open_options(&mut self, value: crate::cap_std_capnp::open_options::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(1), value, false)
      }
      #[inline]
      pub fn init_open_options(self, ) -> crate::cap_std_capnp::open_options::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), 0)
      }
      #[inline]
      pub fn has_open_options(&self) -> bool {
        !self.builder.is_pointer_field_null(1)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_open_options(&self) -> crate::cap_std_capnp::open_options::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(1))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 52] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(62, 233, 64, 78, 25, 127, 137, 204),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(2, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 119, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 111),
        ::capnp::word(112, 101, 110, 87, 105, 116, 104, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(36, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(48, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 98, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(44, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(56, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(111, 112, 101, 110, 79, 112, 116, 105),
        ::capnp::word(111, 110, 115, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(149, 85, 41, 169, 217, 167, 246, 184),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <crate::cap_std_capnp::open_options::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xcc89_7f19_4e40_e93e;
    }
  }

  pub mod open_with_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(183, 62, 188, 184, 30, 208, 145, 186),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 111),
        ::capnp::word(112, 101, 110, 87, 105, 116, 104, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xba91_d01e_b8bc_3eb7;
    }
  }

  pub mod create_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(143, 219, 63, 155, 61, 237, 107, 132),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(114, 101, 97, 116, 101, 68, 105, 114),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x846b_ed3d_9b3f_db8f;
    }
  }

  pub mod create_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(5, 177, 160, 110, 21, 175, 148, 143),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(114, 101, 97, 116, 101, 68, 105, 114),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8f94_af15_6ea0_b105;
    }
  }

  pub mod create_dir_all_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(10, 88, 102, 86, 29, 10, 21, 250),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(114, 101, 97, 116, 101, 68, 105, 114),
        ::capnp::word(65, 108, 108, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xfa15_0a1d_5666_580a;
    }
  }

  pub mod create_dir_all_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(172, 30, 193, 11, 19, 220, 187, 176),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(114, 101, 97, 116, 101, 68, 105, 114),
        ::capnp::word(65, 108, 108, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb0bb_dc13_0bc1_1eac;
    }
  }

  pub mod create_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(171, 91, 125, 130, 108, 228, 77, 226),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 234, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(114, 101, 97, 116, 101, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe24d_e46c_827d_5bab;
    }
  }

  pub mod create_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(208, 13, 245, 143, 141, 149, 224, 230),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 242, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(114, 101, 97, 116, 101, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe6e0_958d_8ff5_0dd0;
    }
  }

  pub mod canonicalize_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(4, 61, 224, 238, 232, 163, 130, 253),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(97, 110, 111, 110, 105, 99, 97, 108),
        ::capnp::word(105, 122, 101, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xfd82_a3e8_eee0_3d04;
    }
  }

  pub mod canonicalize_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path_buf(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path_buf(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path_buf(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path_buf(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path_buf(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path_buf(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(212, 225, 174, 117, 43, 210, 107, 183),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(97, 110, 111, 110, 105, 99, 97, 108),
        ::capnp::word(105, 122, 101, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 66, 117, 102, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb76b_d22b_75ae_e1d4;
    }
  }

  pub mod copy_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path_from(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path_from(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_dir_to(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(1).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir_to(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
      #[inline]
      pub fn get_path_to(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(2), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path_to(&self) -> bool {
        !self.reader.get_pointer_field(2).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 3 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path_from(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path_from(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path_from(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path_from(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_dir_to(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(1).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir_to(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(1).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir_to(&self) -> bool {
        !self.builder.is_pointer_field_null(1)
      }
      #[inline]
      pub fn get_path_to(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(2), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path_to(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(2).set_text(value);
      }
      #[inline]
      pub fn init_path_to(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(2).init_text(size)
      }
      #[inline]
      pub fn has_path_to(&self) -> bool {
        !self.builder.is_pointer_field_null(2)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir_to(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(1).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 67] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(40, 52, 108, 238, 39, 5, 70, 185),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(3, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 218, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 175, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(111, 112, 121, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(69, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(68, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(80, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(77, 0, 0, 0, 50, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(72, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(84, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(2, 0, 0, 0, 2, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 2, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(81, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(76, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(88, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 70, 114, 111, 109),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(100, 105, 114, 84, 111, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(112, 97, 116, 104, 84, 111, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          2 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1,2];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb946_0527_ee6c_3428;
    }
  }

  pub mod copy_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> u64 {
        self.reader.get_data_field::<u64>(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> u64 {
        self.builder.get_data_field::<u64>(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: u64)  {
        self.builder.set_data_field::<u64>(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(79, 9, 187, 111, 5, 230, 197, 188),
        ::capnp::word(47, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 226, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 99),
        ::capnp::word(111, 112, 121, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <u64 as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xbcc5_e605_6fbb_094f;
    }
  }

  pub mod hard_link_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_src_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_src_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_dst_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(1).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dst_dir(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
      #[inline]
      pub fn get_dst_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(2), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_dst_path(&self) -> bool {
        !self.reader.get_pointer_field(2).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 3 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_src_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_src_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_src_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_src_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_dst_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(1).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dst_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(1).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dst_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(1)
      }
      #[inline]
      pub fn get_dst_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(2), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_dst_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(2).set_text(value);
      }
      #[inline]
      pub fn init_dst_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(2).init_text(size)
      }
      #[inline]
      pub fn has_dst_path(&self) -> bool {
        !self.builder.is_pointer_field_null(2)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dst_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(1).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 66] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(208, 106, 218, 80, 105, 28, 54, 248),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(3, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 175, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 104),
        ::capnp::word(97, 114, 100, 76, 105, 110, 107, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(69, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(64, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(76, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(73, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(68, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(80, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(2, 0, 0, 0, 2, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 2, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(77, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(72, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(84, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(115, 114, 99, 80, 97, 116, 104, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(100, 115, 116, 68, 105, 114, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(100, 115, 116, 80, 97, 116, 104, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          2 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1,2];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf836_1c69_50da_6ad0;
    }
  }

  pub mod hard_link_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(215, 68, 233, 189, 218, 25, 114, 184),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 104),
        ::capnp::word(97, 114, 100, 76, 105, 110, 107, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb872_19da_bde9_44d7;
    }
  }

  pub mod metadata_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(247, 135, 185, 163, 73, 243, 65, 144),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 109),
        ::capnp::word(101, 116, 97, 100, 97, 116, 97, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9041_f349_a3b9_87f7;
    }
  }

  pub mod metadata_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_metadata(&mut self, value: crate::cap_std_capnp::metadata::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_metadata(&self) -> crate::cap_std_capnp::metadata::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(236, 48, 45, 47, 27, 45, 236, 169),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 109),
        ::capnp::word(101, 116, 97, 100, 97, 116, 97, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 146, 247, 39, 247, 32, 193, 202),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::metadata::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa9ec_2d1b_2f2d_30ec;
    }
  }

  pub mod dir_metadata_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(32, 14, 160, 74, 12, 195, 237, 244),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 18, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 100),
        ::capnp::word(105, 114, 77, 101, 116, 97, 100, 97),
        ::capnp::word(116, 97, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf4ed_c30c_4aa0_0e20;
    }
  }

  pub mod dir_metadata_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_metadata(&mut self, value: crate::cap_std_capnp::metadata::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_metadata(&self) -> crate::cap_std_capnp::metadata::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(245, 203, 145, 154, 208, 172, 43, 162),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 100),
        ::capnp::word(105, 114, 77, 101, 116, 97, 100, 97),
        ::capnp::word(116, 97, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 146, 247, 39, 247, 32, 193, 202),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::metadata::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa22b_acd0_9a91_cbf5;
    }
  }

  pub mod entries_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(124, 61, 65, 251, 8, 180, 234, 196),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 242, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 101),
        ::capnp::word(110, 116, 114, 105, 101, 115, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc4ea_b408_fb41_3d7c;
    }
  }

  pub mod entries_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_iter(self) -> ::capnp::Result<crate::cap_std_capnp::read_dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_iter(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_iter(self) -> ::capnp::Result<crate::cap_std_capnp::read_dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_iter(&mut self, value: crate::cap_std_capnp::read_dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_iter(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_iter(&self) -> crate::cap_std_capnp::read_dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(209, 222, 55, 117, 155, 233, 129, 171),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 101),
        ::capnp::word(110, 116, 114, 105, 101, 115, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(105, 116, 101, 114, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(207, 62, 23, 252, 46, 206, 101, 236),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::read_dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xab81_e99b_7537_ded1;
    }
  }

  pub mod read_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(139, 129, 64, 245, 135, 89, 85, 241),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 242, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 97, 100, 68, 105, 114, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf155_5987_f540_818b;
    }
  }

  pub mod read_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_iter(self) -> ::capnp::Result<crate::cap_std_capnp::read_dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_iter(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_iter(self) -> ::capnp::Result<crate::cap_std_capnp::read_dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_iter(&mut self, value: crate::cap_std_capnp::read_dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_iter(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_iter(&self) -> crate::cap_std_capnp::read_dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(145, 220, 174, 198, 225, 88, 85, 210),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 97, 100, 68, 105, 114, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(105, 116, 101, 114, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(207, 62, 23, 252, 46, 206, 101, 236),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::read_dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd255_58e1_c6ae_dc91;
    }
  }

  pub mod read_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(224, 39, 229, 137, 250, 24, 146, 130),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 218, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 97, 100, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8292_18fa_89e5_27e0;
    }
  }

  pub mod read_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<::capnp::data::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<::capnp::data::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_result(&mut self, value: ::capnp::data::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_data(value);
      }
      #[inline]
      pub fn init_result(self, size: u32) -> ::capnp::data::Builder<'a> {
        self.builder.get_pointer_field(0).init_data(size)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(5, 79, 169, 224, 202, 240, 160, 130),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 226, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 97, 100, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::data::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x82a0_f0ca_e0a9_4f05;
    }
  }

  pub mod read_link_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(33, 168, 118, 101, 254, 230, 77, 227),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 97, 100, 76, 105, 110, 107, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe34d_e6fe_6576_a821;
    }
  }

  pub mod read_link_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_result(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_result(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(103, 27, 222, 121, 206, 234, 238, 164),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 97, 100, 76, 105, 110, 107, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa4ee_eace_79de_1b67;
    }
  }

  pub mod read_to_string_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(65, 5, 41, 103, 82, 62, 185, 219),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 97, 100, 84, 111, 83, 116, 114),
        ::capnp::word(105, 110, 103, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xdbb9_3e52_6729_0541;
    }
  }

  pub mod read_to_string_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_result(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_result(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(75, 167, 223, 168, 24, 95, 153, 208),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 97, 100, 84, 111, 83, 116, 114),
        ::capnp::word(105, 110, 103, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd099_5f18_a8df_a74b;
    }
  }

  pub mod remove_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(157, 212, 90, 123, 246, 47, 11, 248),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 68, 105, 114),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf80b_2ff6_7b5a_d49d;
    }
  }

  pub mod remove_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(130, 254, 92, 38, 193, 29, 111, 194),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 68, 105, 114),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc26f_1dc1_265c_fe82;
    }
  }

  pub mod remove_dir_all_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(46, 241, 218, 64, 105, 45, 161, 171),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 68, 105, 114),
        ::capnp::word(65, 108, 108, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xaba1_2d69_40da_f12e;
    }
  }

  pub mod remove_dir_all_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(159, 199, 162, 38, 201, 33, 242, 225),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 68, 105, 114),
        ::capnp::word(65, 108, 108, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe1f2_21c9_26a2_c79f;
    }
  }

  pub mod remove_open_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(164, 24, 104, 26, 182, 157, 12, 188),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 79, 112, 101),
        ::capnp::word(110, 68, 105, 114, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xbc0c_9db6_1a68_18a4;
    }
  }

  pub mod remove_open_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(165, 68, 252, 125, 146, 247, 198, 224),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 79, 112, 101),
        ::capnp::word(110, 68, 105, 114, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe0c6_f792_7dfc_44a5;
    }
  }

  pub mod remove_open_dir_all_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(184, 220, 24, 132, 74, 105, 111, 173),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 58, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 79, 112, 101),
        ::capnp::word(110, 68, 105, 114, 65, 108, 108, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xad6f_694a_8418_dcb8;
    }
  }

  pub mod remove_open_dir_all_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(207, 17, 78, 176, 158, 47, 71, 148),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 66, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 79, 112, 101),
        ::capnp::word(110, 68, 105, 114, 65, 108, 108, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9447_2f9e_b04e_11cf;
    }
  }

  pub mod remove_file_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(225, 90, 36, 241, 131, 101, 41, 169),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 70, 105, 108),
        ::capnp::word(101, 36, 80, 97, 114, 97, 109, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa929_6583_f124_5ae1;
    }
  }

  pub mod remove_file_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(195, 116, 190, 226, 106, 18, 0, 198),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 18, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 109, 111, 118, 101, 70, 105, 108),
        ::capnp::word(101, 36, 82, 101, 115, 117, 108, 116),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc600_126a_e2be_74c3;
    }
  }

  pub mod rename_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_from(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_from(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_to(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_to(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 2 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_from(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_from(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_from(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_from(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_to(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_to(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(1).set_text(value);
      }
      #[inline]
      pub fn init_to(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(1).init_text(size)
      }
      #[inline]
      pub fn has_to(&self) -> bool {
        !self.builder.is_pointer_field_null(1)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 51] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(92, 85, 112, 46, 189, 121, 35, 192),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(2, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 234, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 119, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 110, 97, 109, 101, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(36, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(48, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 26, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(40, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(52, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 114, 111, 109, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(116, 111, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc023_79bd_2e70_555c;
    }
  }

  pub mod rename_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(121, 110, 155, 213, 248, 63, 73, 143),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 242, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 114),
        ::capnp::word(101, 110, 97, 109, 101, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8f49_3ff8_d59b_6e79;
    }
  }

  pub mod set_readonly_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_readonly(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_readonly(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_readonly(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 53] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(50, 86, 12, 158, 205, 29, 57, 214),
        ::capnp::word(47, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 18, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 119, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 115),
        ::capnp::word(101, 116, 82, 101, 97, 100, 111, 110),
        ::capnp::word(108, 121, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(36, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(48, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(44, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(56, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(114, 101, 97, 100, 111, 110, 108, 121),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd639_1dcd_9e0c_5632;
    }
  }

  pub mod set_readonly_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(4, 91, 151, 195, 2, 34, 109, 221),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 115),
        ::capnp::word(101, 116, 82, 101, 97, 100, 111, 110),
        ::capnp::word(108, 121, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xdd6d_2202_c397_5b04;
    }
  }

  pub mod symlink_metadata_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(111, 90, 118, 79, 145, 231, 240, 212),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 115),
        ::capnp::word(121, 109, 108, 105, 110, 107, 77, 101),
        ::capnp::word(116, 97, 100, 97, 116, 97, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd4f0_e791_4f76_5a6f;
    }
  }

  pub mod symlink_metadata_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_metadata(&mut self, value: crate::cap_std_capnp::metadata::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_metadata(&self) -> crate::cap_std_capnp::metadata::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(6, 11, 120, 152, 119, 237, 208, 151),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 58, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 115),
        ::capnp::word(121, 109, 108, 105, 110, 107, 77, 101),
        ::capnp::word(116, 97, 100, 97, 116, 97, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 146, 247, 39, 247, 32, 193, 202),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::metadata::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x97d0_ed77_9878_0b06;
    }
  }

  pub mod write_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_contents(self) -> ::capnp::Result<::capnp::data::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_contents(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 2 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_contents(self) -> ::capnp::Result<::capnp::data::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_contents(&mut self, value: ::capnp::data::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(1).set_data(value);
      }
      #[inline]
      pub fn init_contents(self, size: u32) -> ::capnp::data::Builder<'a> {
        self.builder.get_pointer_field(1).init_data(size)
      }
      #[inline]
      pub fn has_contents(&self) -> bool {
        !self.builder.is_pointer_field_null(1)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 52] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(212, 237, 80, 225, 141, 71, 252, 191),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(2, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 226, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 119, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 119),
        ::capnp::word(114, 105, 116, 101, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(36, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(48, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(44, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(56, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(99, 111, 110, 116, 101, 110, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <::capnp::data::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xbffc_478d_e150_edd4;
    }
  }

  pub mod write_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(78, 224, 170, 227, 38, 175, 162, 216),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 234, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 119),
        ::capnp::word(114, 105, 116, 101, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd8a2_af26_e3aa_e04e;
    }
  }

  pub mod symlink_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_original(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_original(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_link(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_link(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 2 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_original(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_original(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_original(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_original(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_link(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_link(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(1).set_text(value);
      }
      #[inline]
      pub fn init_link(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(1).init_text(size)
      }
      #[inline]
      pub fn has_link(&self) -> bool {
        !self.builder.is_pointer_field_null(1)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 52] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(112, 188, 48, 22, 25, 245, 220, 178),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(2, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 242, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 119, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 115),
        ::capnp::word(121, 109, 108, 105, 110, 107, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(40, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(52, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(44, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(56, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(111, 114, 105, 103, 105, 110, 97, 108),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(108, 105, 110, 107, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb2dc_f519_1630_bc70;
    }
  }

  pub mod symlink_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(214, 20, 35, 65, 0, 232, 128, 244),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 115),
        ::capnp::word(121, 109, 108, 105, 110, 107, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf480_e800_4123_14d6;
    }
  }

  pub mod exists_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(28, 218, 166, 84, 184, 124, 83, 197),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 234, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 101),
        ::capnp::word(120, 105, 115, 116, 115, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc553_7cb8_54a6_da1c;
    }
  }

  pub mod exists_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(68, 47, 92, 164, 204, 255, 182, 252),
        ::capnp::word(47, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 242, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 101),
        ::capnp::word(120, 105, 115, 116, 115, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xfcb6_ffcc_a45c_2f44;
    }
  }

  pub mod try_exists_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(214, 56, 241, 14, 25, 130, 80, 185),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 116),
        ::capnp::word(114, 121, 69, 120, 105, 115, 116, 115),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb950_8219_0ef1_38d6;
    }
  }

  pub mod try_exists_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(152, 185, 188, 100, 168, 166, 121, 235),
        ::capnp::word(47, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 116),
        ::capnp::word(114, 121, 69, 120, 105, 115, 116, 115),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xeb79_a6a8_64bc_b998;
    }
  }

  pub mod is_file_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(186, 209, 56, 106, 128, 122, 134, 146),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 234, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 105),
        ::capnp::word(115, 70, 105, 108, 101, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9286_7a80_6a38_d1ba;
    }
  }

  pub mod is_file_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(145, 235, 225, 213, 140, 0, 108, 235),
        ::capnp::word(47, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 242, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 105),
        ::capnp::word(115, 70, 105, 108, 101, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xeb6c_008c_d5e1_eb91;
    }
  }

  pub mod is_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(116, 126, 18, 54, 219, 227, 105, 255),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 226, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 105),
        ::capnp::word(115, 68, 105, 114, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xff69_e3db_3612_7e74;
    }
  }

  pub mod is_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(147, 130, 229, 124, 116, 151, 149, 148),
        ::capnp::word(47, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 234, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 105),
        ::capnp::word(115, 68, 105, 114, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9495_9774_7ce5_8293;
    }
  }

  pub mod temp_dir_new_in_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(63, 34, 41, 36, 125, 84, 135, 159),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 116),
        ::capnp::word(101, 109, 112, 68, 105, 114, 78, 101),
        ::capnp::word(119, 73, 110, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9f87_547d_2429_223f;
    }
  }

  pub mod temp_dir_new_in_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_temp_dir(self) -> ::capnp::Result<crate::cap_std_capnp::temp_dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_temp_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_temp_dir(self) -> ::capnp::Result<crate::cap_std_capnp::temp_dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_temp_dir(&mut self, value: crate::cap_std_capnp::temp_dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_temp_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_temp_dir(&self) -> crate::cap_std_capnp::temp_dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(126, 144, 59, 57, 94, 177, 244, 212),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 116),
        ::capnp::word(101, 109, 112, 68, 105, 114, 78, 101),
        ::capnp::word(119, 73, 110, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(116, 101, 109, 112, 68, 105, 114, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(46, 202, 23, 226, 67, 20, 54, 189),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::temp_dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd4f4_b15e_393b_907e;
    }
  }

  pub mod temp_file_new_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(119, 217, 162, 212, 56, 190, 179, 163),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 18, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 116),
        ::capnp::word(101, 109, 112, 70, 105, 108, 101, 78),
        ::capnp::word(101, 119, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa3b3_be38_d4a2_d977;
    }
  }

  pub mod temp_file_new_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_temp_file(self) -> ::capnp::Result<crate::cap_std_capnp::temp_file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_temp_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_temp_file(self) -> ::capnp::Result<crate::cap_std_capnp::temp_file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_temp_file(&mut self, value: crate::cap_std_capnp::temp_file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_temp_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_temp_file(&self) -> crate::cap_std_capnp::temp_file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(110, 182, 61, 209, 147, 41, 189, 136),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 116),
        ::capnp::word(101, 109, 112, 70, 105, 108, 101, 78),
        ::capnp::word(101, 119, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(116, 101, 109, 112, 70, 105, 108, 101),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(182, 183, 221, 42, 244, 242, 162, 200),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::temp_file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x88bd_2993_d13d_b66e;
    }
  }

  pub mod temp_file_new_anonymous_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 22] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(14, 188, 165, 206, 103, 63, 38, 245),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 90, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 116),
        ::capnp::word(101, 109, 112, 70, 105, 108, 101, 78),
        ::capnp::word(101, 119, 65, 110, 111, 110, 121, 109),
        ::capnp::word(111, 117, 115, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf526_3f67_cea5_bc0e;
    }
  }

  pub mod temp_file_new_anonymous_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(117, 172, 171, 182, 107, 12, 200, 235),
        ::capnp::word(47, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 98, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 46, 116),
        ::capnp::word(101, 109, 112, 70, 105, 108, 101, 78),
        ::capnp::word(101, 119, 65, 110, 111, 110, 121, 109),
        ::capnp::word(111, 117, 115, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xebc8_0c6b_b6ab_ac75;
    }
  }
}


pub mod permissions {
  #![allow(unused_variables)]
  pub type ReadonlyParams<> = ::capnp::capability::Params<crate::cap_std_capnp::permissions::readonly_params::Owned>;
  pub type ReadonlyResults<> = ::capnp::capability::Results<crate::cap_std_capnp::permissions::readonly_results::Owned>;
  pub type SetReadonlyParams<> = ::capnp::capability::Params<crate::cap_std_capnp::permissions::set_readonly_params::Owned>;
  pub type SetReadonlyResults<> = ::capnp::capability::Results<crate::cap_std_capnp::permissions::set_readonly_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn readonly_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::permissions::readonly_params::Owned,crate::cap_std_capnp::permissions::readonly_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn set_readonly_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::permissions::set_readonly_params::Owned,crate::cap_std_capnp::permissions::set_readonly_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn readonly(&self, _: ReadonlyParams<>, _: ReadonlyResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method permissions::Server::readonly not implemented".to_string())) }
    async fn set_readonly(&self, _: SetReadonlyParams<>, _: SetReadonlyResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method permissions::Server::set_readonly not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.readonly(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.set_readonly(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xfc5a_96ce_5008_272d;
    pub static ENCODED_NODE: [::capnp::Word; 44] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(45, 39, 8, 80, 206, 150, 90, 252),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 186, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 135, 0, 0, 0),
      ::capnp::word(129, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 80, 101, 114, 109, 105),
      ::capnp::word(115, 115, 105, 111, 110, 115, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(8, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(226, 138, 224, 150, 121, 214, 213, 215),
      ::capnp::word(190, 103, 6, 120, 201, 169, 150, 229),
      ::capnp::word(49, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(87, 205, 33, 54, 35, 8, 31, 139),
      ::capnp::word(225, 64, 85, 119, 30, 133, 105, 202),
      ::capnp::word(29, 0, 0, 0, 98, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(114, 101, 97, 100, 111, 110, 108, 121),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 101, 116, 82, 101, 97, 100, 111),
      ::capnp::word(110, 108, 121, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod readonly_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(226, 138, 224, 150, 121, 214, 213, 215),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 58, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 101, 114, 109, 105),
        ::capnp::word(115, 115, 105, 111, 110, 115, 46, 114),
        ::capnp::word(101, 97, 100, 111, 110, 108, 121, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd7d5_d679_96e0_8ae2;
    }
  }

  pub mod readonly_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(190, 103, 6, 120, 201, 169, 150, 229),
        ::capnp::word(55, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 66, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 101, 114, 109, 105),
        ::capnp::word(115, 115, 105, 111, 110, 115, 46, 114),
        ::capnp::word(101, 97, 100, 111, 110, 108, 121, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe596_a9c9_7806_67be;
    }
  }

  pub mod set_readonly_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_readonly(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_readonly(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_readonly(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(87, 205, 33, 54, 35, 8, 31, 139),
        ::capnp::word(55, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 82, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 101, 114, 109, 105),
        ::capnp::word(115, 115, 105, 111, 110, 115, 46, 115),
        ::capnp::word(101, 116, 82, 101, 97, 100, 111, 110),
        ::capnp::word(108, 121, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 97, 100, 111, 110, 108, 121),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8b1f_0823_3621_cd57;
    }
  }

  pub mod set_readonly_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 22] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(225, 64, 85, 119, 30, 133, 105, 202),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 90, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 101, 114, 109, 105),
        ::capnp::word(115, 115, 105, 111, 110, 115, 46, 115),
        ::capnp::word(101, 116, 82, 101, 97, 100, 111, 110),
        ::capnp::word(108, 121, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xca69_851e_7755_40e1;
    }
  }
}


pub mod metadata {
  #![allow(unused_variables)]
  pub type FileTypeParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::file_type_params::Owned>;
  pub type FileTypeResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::file_type_results::Owned>;
  pub type IsDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::is_dir_params::Owned>;
  pub type IsDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::is_dir_results::Owned>;
  pub type IsFileParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::is_file_params::Owned>;
  pub type IsFileResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::is_file_results::Owned>;
  pub type IsSymlinkParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::is_symlink_params::Owned>;
  pub type IsSymlinkResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::is_symlink_results::Owned>;
  pub type LenParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::len_params::Owned>;
  pub type LenResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::len_results::Owned>;
  pub type PermissionsParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::permissions_params::Owned>;
  pub type PermissionsResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::permissions_results::Owned>;
  pub type ModifiedParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::modified_params::Owned>;
  pub type ModifiedResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::modified_results::Owned>;
  pub type AccessedParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::accessed_params::Owned>;
  pub type AccessedResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::accessed_results::Owned>;
  pub type CreatedParams<> = ::capnp::capability::Params<crate::cap_std_capnp::metadata::created_params::Owned>;
  pub type CreatedResults<> = ::capnp::capability::Results<crate::cap_std_capnp::metadata::created_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn file_type_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::file_type_params::Owned,crate::cap_std_capnp::metadata::file_type_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn is_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::is_dir_params::Owned,crate::cap_std_capnp::metadata::is_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
    pub fn is_file_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::is_file_params::Owned,crate::cap_std_capnp::metadata::is_file_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 2, ::core::option::Option::None)
    }
    pub fn is_symlink_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::is_symlink_params::Owned,crate::cap_std_capnp::metadata::is_symlink_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 3, ::core::option::Option::None)
    }
    pub fn len_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::len_params::Owned,crate::cap_std_capnp::metadata::len_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 4, ::core::option::Option::None)
    }
    pub fn permissions_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::permissions_params::Owned,crate::cap_std_capnp::metadata::permissions_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 5, ::core::option::Option::None)
    }
    pub fn modified_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::modified_params::Owned,crate::cap_std_capnp::metadata::modified_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 6, ::core::option::Option::None)
    }
    pub fn accessed_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::accessed_params::Owned,crate::cap_std_capnp::metadata::accessed_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 7, ::core::option::Option::None)
    }
    pub fn created_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::metadata::created_params::Owned,crate::cap_std_capnp::metadata::created_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 8, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn file_type(&self, _: FileTypeParams<>, _: FileTypeResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::file_type not implemented".to_string())) }
    async fn is_dir(&self, _: IsDirParams<>, _: IsDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::is_dir not implemented".to_string())) }
    async fn is_file(&self, _: IsFileParams<>, _: IsFileResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::is_file not implemented".to_string())) }
    async fn is_symlink(&self, _: IsSymlinkParams<>, _: IsSymlinkResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::is_symlink not implemented".to_string())) }
    async fn len(&self, _: LenParams<>, _: LenResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::len not implemented".to_string())) }
    async fn permissions(&self, _: PermissionsParams<>, _: PermissionsResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::permissions not implemented".to_string())) }
    async fn modified(&self, _: ModifiedParams<>, _: ModifiedResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::modified not implemented".to_string())) }
    async fn accessed(&self, _: AccessedParams<>, _: AccessedResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::accessed not implemented".to_string())) }
    async fn created(&self, _: CreatedParams<>, _: CreatedResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method metadata::Server::created not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.file_type(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.is_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          2 => server.is_file(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          3 => server.is_symlink(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          4 => server.len(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          5 => server.permissions(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          6 => server.modified(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          7 => server.accessed(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          8 => server.created(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xcac1_20f7_27f7_9215;
    pub static ENCODED_NODE: [::capnp::Word; 117] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(21, 146, 247, 39, 247, 32, 193, 202),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 162, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 71, 2, 0, 0),
      ::capnp::word(165, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
      ::capnp::word(97, 116, 97, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(36, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 102, 247, 126, 236, 255, 96, 161),
      ::capnp::word(148, 230, 78, 2, 167, 66, 56, 169),
      ::capnp::word(17, 1, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(9, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(208, 248, 10, 44, 128, 34, 89, 175),
      ::capnp::word(49, 119, 118, 145, 142, 76, 32, 169),
      ::capnp::word(253, 0, 0, 0, 50, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(241, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(189, 105, 142, 138, 60, 43, 229, 163),
      ::capnp::word(136, 186, 159, 71, 231, 222, 220, 132),
      ::capnp::word(229, 0, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(217, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(47, 63, 94, 162, 208, 32, 98, 208),
      ::capnp::word(220, 120, 1, 25, 177, 3, 50, 201),
      ::capnp::word(205, 0, 0, 0, 82, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(197, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(92, 232, 125, 236, 46, 43, 6, 130),
      ::capnp::word(103, 59, 34, 5, 14, 202, 6, 150),
      ::capnp::word(185, 0, 0, 0, 34, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(173, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(112, 93, 111, 231, 47, 156, 17, 190),
      ::capnp::word(115, 108, 147, 230, 1, 210, 94, 226),
      ::capnp::word(161, 0, 0, 0, 98, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(153, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(17, 201, 145, 212, 223, 177, 157, 129),
      ::capnp::word(191, 90, 8, 104, 40, 87, 166, 182),
      ::capnp::word(141, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(133, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(177, 220, 76, 82, 255, 248, 67, 197),
      ::capnp::word(224, 198, 153, 190, 89, 227, 38, 200),
      ::capnp::word(121, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(113, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(56, 150, 54, 28, 20, 213, 208, 253),
      ::capnp::word(148, 209, 242, 56, 46, 33, 197, 206),
      ::capnp::word(101, 0, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(89, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(102, 105, 108, 101, 84, 121, 112, 101),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(105, 115, 68, 105, 114, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(105, 115, 70, 105, 108, 101, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(105, 115, 83, 121, 109, 108, 105, 110),
      ::capnp::word(107, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(108, 101, 110, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(112, 101, 114, 109, 105, 115, 115, 105),
      ::capnp::word(111, 110, 115, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(109, 111, 100, 105, 102, 105, 101, 100),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(97, 99, 99, 101, 115, 115, 101, 100),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 114, 101, 97, 116, 101, 100, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod file_type_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(70, 102, 247, 126, 236, 255, 96, 161),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 102, 105, 108, 101),
        ::capnp::word(84, 121, 112, 101, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa160_ffec_7ef7_6646;
    }
  }

  pub mod file_type_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file_type(self) -> ::core::result::Result<crate::cap_std_capnp::FileType,::capnp::NotInSchema> {
        ::core::convert::TryInto::try_into(self.reader.get_data_field::<u16>(0))
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file_type(self) -> ::core::result::Result<crate::cap_std_capnp::FileType,::capnp::NotInSchema> {
        ::core::convert::TryInto::try_into(self.builder.get_data_field::<u16>(0))
      }
      #[inline]
      pub fn set_file_type(&mut self, value: crate::cap_std_capnp::FileType)  {
        self.builder.set_data_field::<u16>(0, value as u16);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(148, 230, 78, 2, 167, 66, 56, 169),
        ::capnp::word(52, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 102, 105, 108, 101),
        ::capnp::word(84, 121, 112, 101, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 84, 121, 112, 101),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(15, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(47, 164, 243, 213, 37, 175, 85, 167),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(15, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::FileType as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa938_42a7_024e_e694;
    }
  }

  pub mod is_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(208, 248, 10, 44, 128, 34, 89, 175),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 105, 115, 68, 105),
        ::capnp::word(114, 36, 80, 97, 114, 97, 109, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xaf59_2280_2c0a_f8d0;
    }
  }

  pub mod is_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(49, 119, 118, 145, 142, 76, 32, 169),
        ::capnp::word(52, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 18, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 105, 115, 68, 105),
        ::capnp::word(114, 36, 82, 101, 115, 117, 108, 116),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa920_4c8e_9176_7731;
    }
  }

  pub mod is_file_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(189, 105, 142, 138, 60, 43, 229, 163),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 18, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 105, 115, 70, 105),
        ::capnp::word(108, 101, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa3e5_2b3c_8a8e_69bd;
    }
  }

  pub mod is_file_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(136, 186, 159, 71, 231, 222, 220, 132),
        ::capnp::word(52, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 105, 115, 70, 105),
        ::capnp::word(108, 101, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x84dc_dee7_479f_ba88;
    }
  }

  pub mod is_symlink_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(47, 63, 94, 162, 208, 32, 98, 208),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 105, 115, 83, 121),
        ::capnp::word(109, 108, 105, 110, 107, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd062_20d0_a25e_3f2f;
    }
  }

  pub mod is_symlink_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.reader.get_bool_field(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> bool {
        self.builder.get_bool_field(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: bool)  {
        self.builder.set_bool_field(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(220, 120, 1, 25, 177, 3, 50, 201),
        ::capnp::word(52, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 105, 115, 83, 121),
        ::capnp::word(109, 108, 105, 110, 107, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <bool as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc932_03b1_1901_78dc;
    }
  }

  pub mod len_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(92, 232, 125, 236, 46, 43, 6, 130),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 108, 101, 110, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8206_2b2e_ec7d_e85c;
    }
  }

  pub mod len_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> u64 {
        self.reader.get_data_field::<u64>(0)
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> u64 {
        self.builder.get_data_field::<u64>(0)
      }
      #[inline]
      pub fn set_result(&mut self, value: u64)  {
        self.builder.set_data_field::<u64>(0, value);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(103, 59, 34, 5, 14, 202, 6, 150),
        ::capnp::word(52, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 108, 101, 110, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <u64 as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9606_ca0e_0522_3b67;
    }
  }

  pub mod permissions_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(112, 93, 111, 231, 47, 156, 17, 190),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 58, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 112, 101, 114, 109),
        ::capnp::word(105, 115, 115, 105, 111, 110, 115, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xbe11_9c2f_e76f_5d70;
    }
  }

  pub mod permissions_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_permissions(self) -> ::capnp::Result<crate::cap_std_capnp::permissions::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_permissions(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_permissions(self) -> ::capnp::Result<crate::cap_std_capnp::permissions::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_permissions(&mut self, value: crate::cap_std_capnp::permissions::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_permissions(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_permissions(&self) -> crate::cap_std_capnp::permissions::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(115, 108, 147, 230, 1, 210, 94, 226),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 66, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 112, 101, 114, 109),
        ::capnp::word(105, 115, 115, 105, 111, 110, 115, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 98, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 101, 114, 109, 105, 115, 115, 105),
        ::capnp::word(111, 110, 115, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 39, 8, 80, 206, 150, 90, 252),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::permissions::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe25e_d201_e693_6c73;
    }
  }

  pub mod modified_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(17, 201, 145, 212, 223, 177, 157, 129),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 109, 111, 100, 105),
        ::capnp::word(102, 105, 101, 100, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x819d_b1df_d491_c911;
    }
  }

  pub mod modified_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_time(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_time(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_time(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_time(&mut self, value: crate::cap_std_capnp::system_time::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_time(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_time(&self) -> crate::cap_std_capnp::system_time::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(191, 90, 8, 104, 40, 87, 166, 182),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 109, 111, 100, 105),
        ::capnp::word(102, 105, 101, 100, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(116, 105, 109, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(243, 95, 172, 103, 65, 180, 240, 195),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::system_time::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb6a6_5728_6808_5abf;
    }
  }

  pub mod accessed_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(177, 220, 76, 82, 255, 248, 67, 197),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 97, 99, 99, 101),
        ::capnp::word(115, 115, 101, 100, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc543_f8ff_524c_dcb1;
    }
  }

  pub mod accessed_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_time(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_time(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_time(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_time(&mut self, value: crate::cap_std_capnp::system_time::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_time(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_time(&self) -> crate::cap_std_capnp::system_time::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(224, 198, 153, 190, 89, 227, 38, 200),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 97, 99, 99, 101),
        ::capnp::word(115, 115, 101, 100, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(116, 105, 109, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(243, 95, 172, 103, 65, 180, 240, 195),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::system_time::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc826_e359_be99_c6e0;
    }
  }

  pub mod created_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(56, 150, 54, 28, 20, 213, 208, 253),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 99, 114, 101, 97),
        ::capnp::word(116, 101, 100, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xfdd0_d514_1c36_9638;
    }
  }

  pub mod created_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_time(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_time(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_time(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_time(&mut self, value: crate::cap_std_capnp::system_time::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_time(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_time(&self) -> crate::cap_std_capnp::system_time::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(148, 209, 242, 56, 46, 33, 197, 206),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 101, 116, 97, 100),
        ::capnp::word(97, 116, 97, 46, 99, 114, 101, 97),
        ::capnp::word(116, 101, 100, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(116, 105, 109, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(243, 95, 172, 103, 65, 180, 240, 195),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::system_time::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xcec5_212e_38f2_d194;
    }
  }
}

pub mod duration {
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
  impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

  pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
  impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
  impl <'a,> ::core::clone::Clone for Reader<'a,>  {
    fn clone(&self) -> Self { *self }
  }

  impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
    fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
      Self { reader,  }
    }
  }

  impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
    fn from(reader: Reader<'a,>) -> Self {
      Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
    }
  }

  impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
      core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
    }
  }

  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(reader.get_struct(default)?.into())
    }
  }

  impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
    fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
      self.reader
    }
  }

  impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
    fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
      self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
    }
  }

  impl <'a,> Reader<'a,>  {
    pub fn reborrow(&self) -> Reader<'_,> {
      Self { .. *self }
    }

    pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
      self.reader.total_size()
    }
    #[inline]
    pub fn get_secs(self) -> u64 {
      self.reader.get_data_field::<u64>(0)
    }
    #[inline]
    pub fn get_nanos(self) -> u32 {
      self.reader.get_data_field::<u32>(2)
    }
  }

  pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
  impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
    const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 2, pointers: 0 };
  }
  impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
    fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
      Self { builder,  }
    }
  }

  impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
    fn from(builder: Builder<'a,>) -> Self {
      Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
    }
  }

  impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
    fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
      self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
    }
  }

  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
    fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
    }
  }

  impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
  }

  impl <'a,> Builder<'a,>  {
    pub fn into_reader(self) -> Reader<'a,> {
      self.builder.into_reader().into()
    }
    pub fn reborrow(&mut self) -> Builder<'_,> {
      Builder { builder: self.builder.reborrow() }
    }
    pub fn reborrow_as_reader(&self) -> Reader<'_,> {
      self.builder.as_reader().into()
    }

    pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
      self.builder.as_reader().total_size()
    }
    #[inline]
    pub fn get_secs(self) -> u64 {
      self.builder.get_data_field::<u64>(0)
    }
    #[inline]
    pub fn set_secs(&mut self, value: u64)  {
      self.builder.set_data_field::<u64>(0, value);
    }
    #[inline]
    pub fn get_nanos(self) -> u32 {
      self.builder.get_data_field::<u32>(2)
    }
    #[inline]
    pub fn set_nanos(&mut self, value: u32)  {
      self.builder.set_data_field::<u32>(2, value);
    }
  }

  pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
  impl ::capnp::capability::FromTypelessPipeline for Pipeline {
    fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
      Self { _typeless: typeless,  }
    }
  }
  impl Pipeline  {
  }
  mod _private {
    pub static ENCODED_NODE: [::capnp::Word; 51] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
      ::capnp::word(43, 0, 0, 0, 1, 0, 2, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 162, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 119, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 68, 117, 114, 97, 116),
      ::capnp::word(105, 111, 110, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(8, 0, 0, 0, 3, 0, 4, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 42, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(36, 0, 0, 0, 3, 0, 1, 0),
      ::capnp::word(48, 0, 0, 0, 2, 0, 1, 0),
      ::capnp::word(1, 0, 0, 0, 2, 0, 0, 0),
      ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(45, 0, 0, 0, 50, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(40, 0, 0, 0, 3, 0, 1, 0),
      ::capnp::word(52, 0, 0, 0, 2, 0, 1, 0),
      ::capnp::word(115, 101, 99, 115, 0, 0, 0, 0),
      ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(110, 97, 110, 111, 115, 0, 0, 0),
      ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
    ];
    pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
      match index {
        0 => <u64 as ::capnp::introspect::Introspect>::introspect(),
        1 => <u32 as ::capnp::introspect::Introspect>::introspect(),
        _ => panic!("invalid field index {}", index),
      }
    }
    pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
      panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
    }
    pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
      encoded_node: &ENCODED_NODE,
      nonunion_members: NONUNION_MEMBERS,
      members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
    };
    pub static NONUNION_MEMBERS : &[u16] = &[0,1];
    pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
    pub const TYPE_ID: u64 = 0x8bf3_aa84_e436_2ba8;
  }
}


pub mod instant {
  #![allow(unused_variables)]
  pub type DurationSinceParams<> = ::capnp::capability::Params<crate::cap_std_capnp::instant::duration_since_params::Owned>;
  pub type DurationSinceResults<> = ::capnp::capability::Results<crate::cap_std_capnp::instant::duration_since_results::Owned>;
  pub type CheckedDurationSinceParams<> = ::capnp::capability::Params<crate::cap_std_capnp::instant::checked_duration_since_params::Owned>;
  pub type CheckedDurationSinceResults<> = ::capnp::capability::Results<crate::cap_std_capnp::instant::checked_duration_since_results::Owned>;
  pub type SaturatingDurationSinceParams<> = ::capnp::capability::Params<crate::cap_std_capnp::instant::saturating_duration_since_params::Owned>;
  pub type SaturatingDurationSinceResults<> = ::capnp::capability::Results<crate::cap_std_capnp::instant::saturating_duration_since_results::Owned>;
  pub type CheckedAddParams<> = ::capnp::capability::Params<crate::cap_std_capnp::instant::checked_add_params::Owned>;
  pub type CheckedAddResults<> = ::capnp::capability::Results<crate::cap_std_capnp::instant::checked_add_results::Owned>;
  pub type CheckedSubParams<> = ::capnp::capability::Params<crate::cap_std_capnp::instant::checked_sub_params::Owned>;
  pub type CheckedSubResults<> = ::capnp::capability::Results<crate::cap_std_capnp::instant::checked_sub_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn duration_since_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::instant::duration_since_params::Owned,crate::cap_std_capnp::instant::duration_since_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn checked_duration_since_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::instant::checked_duration_since_params::Owned,crate::cap_std_capnp::instant::checked_duration_since_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
    pub fn saturating_duration_since_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::instant::saturating_duration_since_params::Owned,crate::cap_std_capnp::instant::saturating_duration_since_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 2, ::core::option::Option::None)
    }
    pub fn checked_add_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::instant::checked_add_params::Owned,crate::cap_std_capnp::instant::checked_add_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 3, ::core::option::Option::None)
    }
    pub fn checked_sub_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::instant::checked_sub_params::Owned,crate::cap_std_capnp::instant::checked_sub_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 4, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn duration_since(&self, _: DurationSinceParams<>, _: DurationSinceResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method instant::Server::duration_since not implemented".to_string())) }
    async fn checked_duration_since(&self, _: CheckedDurationSinceParams<>, _: CheckedDurationSinceResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method instant::Server::checked_duration_since not implemented".to_string())) }
    async fn saturating_duration_since(&self, _: SaturatingDurationSinceParams<>, _: SaturatingDurationSinceResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method instant::Server::saturating_duration_since not implemented".to_string())) }
    async fn checked_add(&self, _: CheckedAddParams<>, _: CheckedAddResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method instant::Server::checked_add not implemented".to_string())) }
    async fn checked_sub(&self, _: CheckedSubParams<>, _: CheckedSubResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method instant::Server::checked_sub not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.duration_since(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.checked_duration_since(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          2 => server.saturating_duration_since(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          3 => server.checked_add(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          4 => server.checked_sub(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0x8f4f_b585_e5ad_412a;
    pub static ENCODED_NODE: [::capnp::Word; 79] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(42, 65, 173, 229, 133, 181, 79, 143),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 154, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 71, 1, 0, 0),
      ::capnp::word(13, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
      ::capnp::word(110, 116, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(20, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(68, 75, 172, 181, 41, 181, 110, 175),
      ::capnp::word(243, 130, 7, 183, 202, 123, 51, 147),
      ::capnp::word(145, 0, 0, 0, 114, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(137, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(42, 145, 140, 155, 131, 224, 92, 234),
      ::capnp::word(230, 55, 27, 214, 144, 49, 245, 158),
      ::capnp::word(125, 0, 0, 0, 170, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(121, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(71, 215, 229, 22, 96, 28, 200, 226),
      ::capnp::word(168, 60, 50, 200, 2, 60, 248, 148),
      ::capnp::word(109, 0, 0, 0, 194, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(105, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(147, 45, 114, 217, 190, 109, 137, 236),
      ::capnp::word(14, 58, 20, 89, 244, 235, 164, 134),
      ::capnp::word(93, 0, 0, 0, 90, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(85, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(233, 152, 42, 83, 250, 37, 145, 164),
      ::capnp::word(255, 152, 62, 39, 55, 71, 190, 242),
      ::capnp::word(73, 0, 0, 0, 90, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(65, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
      ::capnp::word(83, 105, 110, 99, 101, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 104, 101, 99, 107, 101, 100, 68),
      ::capnp::word(117, 114, 97, 116, 105, 111, 110, 83),
      ::capnp::word(105, 110, 99, 101, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 97, 116, 117, 114, 97, 116, 105),
      ::capnp::word(110, 103, 68, 117, 114, 97, 116, 105),
      ::capnp::word(111, 110, 83, 105, 110, 99, 101, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 104, 101, 99, 107, 101, 100, 65),
      ::capnp::word(100, 100, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 104, 101, 99, 107, 101, 100, 83),
      ::capnp::word(117, 98, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod duration_since_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_earlier(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_earlier(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_earlier(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_earlier(&mut self, value: crate::cap_std_capnp::instant::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_earlier(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_earlier(&self) -> crate::cap_std_capnp::instant::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(68, 75, 172, 181, 41, 181, 110, 175),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 66, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 100, 117, 114, 97, 116),
        ::capnp::word(105, 111, 110, 83, 105, 110, 99, 101),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(101, 97, 114, 108, 105, 101, 114, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(42, 65, 173, 229, 133, 181, 79, 143),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::instant::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xaf6e_b529_b5ac_4b44;
    }
  }

  pub mod duration_since_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(243, 130, 7, 183, 202, 123, 51, 147),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 74, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 100, 117, 114, 97, 116),
        ::capnp::word(105, 111, 110, 83, 105, 110, 99, 101),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9333_7bca_b707_82f3;
    }
  }

  pub mod checked_duration_since_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_earlier(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_earlier(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_earlier(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_earlier(&mut self, value: crate::cap_std_capnp::instant::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_earlier(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_earlier(&self) -> crate::cap_std_capnp::instant::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(42, 145, 140, 155, 131, 224, 92, 234),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 122, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 99, 104, 101, 99, 107),
        ::capnp::word(101, 100, 68, 117, 114, 97, 116, 105),
        ::capnp::word(111, 110, 83, 105, 110, 99, 101, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(101, 97, 114, 108, 105, 101, 114, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(42, 65, 173, 229, 133, 181, 79, 143),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::instant::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xea5c_e083_9b8c_912a;
    }
  }

  pub mod checked_duration_since_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(230, 55, 27, 214, 144, 49, 245, 158),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 130, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 99, 104, 101, 99, 107),
        ::capnp::word(101, 100, 68, 117, 114, 97, 116, 105),
        ::capnp::word(111, 110, 83, 105, 110, 99, 101, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9ef5_3190_d61b_37e6;
    }
  }

  pub mod saturating_duration_since_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_earlier(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_earlier(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_earlier(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_earlier(&mut self, value: crate::cap_std_capnp::instant::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_earlier(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_earlier(&self) -> crate::cap_std_capnp::instant::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(71, 215, 229, 22, 96, 28, 200, 226),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 146, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 115, 97, 116, 117, 114),
        ::capnp::word(97, 116, 105, 110, 103, 68, 117, 114),
        ::capnp::word(97, 116, 105, 111, 110, 83, 105, 110),
        ::capnp::word(99, 101, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(101, 97, 114, 108, 105, 101, 114, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(42, 65, 173, 229, 133, 181, 79, 143),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::instant::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe2c8_1c60_16e5_d747;
    }
  }

  pub mod saturating_duration_since_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 40] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(168, 60, 50, 200, 2, 60, 248, 148),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 154, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 115, 97, 116, 117, 114),
        ::capnp::word(97, 116, 105, 110, 103, 68, 117, 114),
        ::capnp::word(97, 116, 105, 111, 110, 83, 105, 110),
        ::capnp::word(99, 101, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x94f8_3c02_c832_3ca8;
    }
  }

  pub mod checked_add_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(147, 45, 114, 217, 190, 109, 137, 236),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 99, 104, 101, 99, 107),
        ::capnp::word(101, 100, 65, 100, 100, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xec89_6dbe_d972_2d93;
    }
  }

  pub mod checked_add_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_instant(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_instant(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_instant(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_instant(&mut self, value: crate::cap_std_capnp::instant::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_instant(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_instant(&self) -> crate::cap_std_capnp::instant::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(14, 58, 20, 89, 244, 235, 164, 134),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 99, 104, 101, 99, 107),
        ::capnp::word(101, 100, 65, 100, 100, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(105, 110, 115, 116, 97, 110, 116, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(42, 65, 173, 229, 133, 181, 79, 143),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::instant::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x86a4_ebf4_5914_3a0e;
    }
  }

  pub mod checked_sub_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(233, 152, 42, 83, 250, 37, 145, 164),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 99, 104, 101, 99, 107),
        ::capnp::word(101, 100, 83, 117, 98, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa491_25fa_532a_98e9;
    }
  }

  pub mod checked_sub_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_instant(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_instant(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_instant(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_instant(&mut self, value: crate::cap_std_capnp::instant::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_instant(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_instant(&self) -> crate::cap_std_capnp::instant::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(255, 152, 62, 39, 55, 71, 190, 242),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 73, 110, 115, 116, 97),
        ::capnp::word(110, 116, 46, 99, 104, 101, 99, 107),
        ::capnp::word(101, 100, 83, 117, 98, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(105, 110, 115, 116, 97, 110, 116, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(42, 65, 173, 229, 133, 181, 79, 143),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::instant::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf2be_4737_273e_98ff;
    }
  }
}


pub mod monotonic_clock {
  #![allow(unused_variables)]
  pub type NowParams<> = ::capnp::capability::Params<crate::cap_std_capnp::monotonic_clock::now_params::Owned>;
  pub type NowResults<> = ::capnp::capability::Results<crate::cap_std_capnp::monotonic_clock::now_results::Owned>;
  pub type ElapsedParams<> = ::capnp::capability::Params<crate::cap_std_capnp::monotonic_clock::elapsed_params::Owned>;
  pub type ElapsedResults<> = ::capnp::capability::Results<crate::cap_std_capnp::monotonic_clock::elapsed_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn now_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::monotonic_clock::now_params::Owned,crate::cap_std_capnp::monotonic_clock::now_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn elapsed_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::monotonic_clock::elapsed_params::Owned,crate::cap_std_capnp::monotonic_clock::elapsed_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn now(&self, _: NowParams<>, _: NowResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method monotonic_clock::Server::now not implemented".to_string())) }
    async fn elapsed(&self, _: ElapsedParams<>, _: ElapsedResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method monotonic_clock::Server::elapsed not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.now(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.elapsed(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0x992a_9bd6_122d_5065;
    pub static ENCODED_NODE: [::capnp::Word; 43] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(101, 80, 45, 18, 214, 155, 42, 153),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 210, 1, 0, 0),
      ::capnp::word(49, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(45, 0, 0, 0, 135, 0, 0, 0),
      ::capnp::word(125, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 77, 111, 110, 111, 116),
      ::capnp::word(111, 110, 105, 99, 67, 108, 111, 99),
      ::capnp::word(107, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(8, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(175, 64, 153, 232, 198, 150, 230, 148),
      ::capnp::word(79, 201, 52, 200, 91, 127, 253, 192),
      ::capnp::word(49, 0, 0, 0, 34, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(201, 157, 163, 170, 220, 25, 189, 216),
      ::capnp::word(45, 132, 199, 2, 1, 218, 254, 138),
      ::capnp::word(25, 0, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(13, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(110, 111, 119, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(101, 108, 97, 112, 115, 101, 100, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod now_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(175, 64, 153, 232, 198, 150, 230, 148),
        ::capnp::word(58, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 111, 110, 111, 116),
        ::capnp::word(111, 110, 105, 99, 67, 108, 111, 99),
        ::capnp::word(107, 46, 110, 111, 119, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x94e6_96c6_e899_40af;
    }
  }

  pub mod now_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_instant(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_instant(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_instant(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_instant(&mut self, value: crate::cap_std_capnp::instant::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_instant(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_instant(&self) -> crate::cap_std_capnp::instant::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(79, 201, 52, 200, 91, 127, 253, 192),
        ::capnp::word(58, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 111, 110, 111, 116),
        ::capnp::word(111, 110, 105, 99, 67, 108, 111, 99),
        ::capnp::word(107, 46, 110, 111, 119, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(105, 110, 115, 116, 97, 110, 116, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(42, 65, 173, 229, 133, 181, 79, 143),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::instant::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc0fd_7f5b_c834_c94f;
    }
  }

  pub mod elapsed_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_instant(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_instant(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_instant(self) -> ::capnp::Result<crate::cap_std_capnp::instant::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_instant(&mut self, value: crate::cap_std_capnp::instant::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_instant(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_instant(&self) -> crate::cap_std_capnp::instant::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(201, 157, 163, 170, 220, 25, 189, 216),
        ::capnp::word(58, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 74, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 111, 110, 111, 116),
        ::capnp::word(111, 110, 105, 99, 67, 108, 111, 99),
        ::capnp::word(107, 46, 101, 108, 97, 112, 115, 101),
        ::capnp::word(100, 36, 80, 97, 114, 97, 109, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(105, 110, 115, 116, 97, 110, 116, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(42, 65, 173, 229, 133, 181, 79, 143),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::instant::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd8bd_19dc_aaa3_9dc9;
    }
  }

  pub mod elapsed_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(45, 132, 199, 2, 1, 218, 254, 138),
        ::capnp::word(58, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 82, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 77, 111, 110, 111, 116),
        ::capnp::word(111, 110, 105, 99, 67, 108, 111, 99),
        ::capnp::word(107, 46, 101, 108, 97, 112, 115, 101),
        ::capnp::word(100, 36, 82, 101, 115, 117, 108, 116),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8afe_da01_02c7_842d;
    }
  }
}


pub mod system_clock {
  #![allow(unused_variables)]
  pub type NowParams<> = ::capnp::capability::Params<crate::cap_std_capnp::system_clock::now_params::Owned>;
  pub type NowResults<> = ::capnp::capability::Results<crate::cap_std_capnp::system_clock::now_results::Owned>;
  pub type ElapsedParams<> = ::capnp::capability::Params<crate::cap_std_capnp::system_clock::elapsed_params::Owned>;
  pub type ElapsedResults<> = ::capnp::capability::Results<crate::cap_std_capnp::system_clock::elapsed_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn now_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::system_clock::now_params::Owned,crate::cap_std_capnp::system_clock::now_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn elapsed_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::system_clock::elapsed_params::Owned,crate::cap_std_capnp::system_clock::elapsed_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn now(&self, _: NowParams<>, _: NowResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method system_clock::Server::now not implemented".to_string())) }
    async fn elapsed(&self, _: ElapsedParams<>, _: ElapsedResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method system_clock::Server::elapsed not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.now(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.elapsed(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0x9e38_2b9b_fc1b_bfc8;
    pub static ENCODED_NODE: [::capnp::Word; 42] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(200, 191, 27, 252, 155, 43, 56, 158),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 186, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 135, 0, 0, 0),
      ::capnp::word(121, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
      ::capnp::word(109, 67, 108, 111, 99, 107, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(8, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(203, 121, 166, 232, 101, 209, 57, 223),
      ::capnp::word(124, 65, 74, 25, 151, 85, 125, 151),
      ::capnp::word(49, 0, 0, 0, 34, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(224, 157, 23, 165, 193, 22, 1, 153),
      ::capnp::word(210, 61, 159, 115, 240, 53, 212, 211),
      ::capnp::word(25, 0, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(13, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(110, 111, 119, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(101, 108, 97, 112, 115, 101, 100, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod now_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(203, 121, 166, 232, 101, 209, 57, 223),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 18, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 67, 108, 111, 99, 107, 46, 110),
        ::capnp::word(111, 119, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xdf39_d165_e8a6_79cb;
    }
  }

  pub mod now_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_time(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_time(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_time(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_time(&mut self, value: crate::cap_std_capnp::system_time::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_time(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_time(&self) -> crate::cap_std_capnp::system_time::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(124, 65, 74, 25, 151, 85, 125, 151),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 67, 108, 111, 99, 107, 46, 110),
        ::capnp::word(111, 119, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(116, 105, 109, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(243, 95, 172, 103, 65, 180, 240, 195),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::system_time::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x977d_5597_194a_417c;
    }
  }

  pub mod elapsed_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration_since_unix_epoch(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration_since_unix_epoch(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration_since_unix_epoch(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration_since_unix_epoch(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration_since_unix_epoch(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration_since_unix_epoch(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration_since_unix_epoch(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(224, 157, 23, 165, 193, 22, 1, 153),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 67, 108, 111, 99, 107, 46, 101),
        ::capnp::word(108, 97, 112, 115, 101, 100, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 186, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(28, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(83, 105, 110, 99, 101, 85, 110, 105),
        ::capnp::word(120, 69, 112, 111, 99, 104, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9901_16c1_a517_9de0;
    }
  }

  pub mod elapsed_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_result(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_result(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_result(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(210, 61, 159, 115, 240, 53, 212, 211),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 58, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 67, 108, 111, 99, 107, 46, 101),
        ::capnp::word(108, 97, 112, 115, 101, 100, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd3d4_35f0_739f_3dd2;
    }
  }
}


pub mod system_time {
  #![allow(unused_variables)]
  pub type DurationSinceParams<> = ::capnp::capability::Params<crate::cap_std_capnp::system_time::duration_since_params::Owned>;
  pub type DurationSinceResults<> = ::capnp::capability::Results<crate::cap_std_capnp::system_time::duration_since_results::Owned>;
  pub type CheckedAddParams<> = ::capnp::capability::Params<crate::cap_std_capnp::system_time::checked_add_params::Owned>;
  pub type CheckedAddResults<> = ::capnp::capability::Results<crate::cap_std_capnp::system_time::checked_add_results::Owned>;
  pub type CheckedSubParams<> = ::capnp::capability::Params<crate::cap_std_capnp::system_time::checked_sub_params::Owned>;
  pub type CheckedSubResults<> = ::capnp::capability::Results<crate::cap_std_capnp::system_time::checked_sub_results::Owned>;
  pub type GetDurationSinceUnixEpochParams<> = ::capnp::capability::Params<crate::cap_std_capnp::system_time::get_duration_since_unix_epoch_params::Owned>;
  pub type GetDurationSinceUnixEpochResults<> = ::capnp::capability::Results<crate::cap_std_capnp::system_time::get_duration_since_unix_epoch_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn duration_since_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::system_time::duration_since_params::Owned,crate::cap_std_capnp::system_time::duration_since_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn checked_add_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::system_time::checked_add_params::Owned,crate::cap_std_capnp::system_time::checked_add_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
    pub fn checked_sub_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::system_time::checked_sub_params::Owned,crate::cap_std_capnp::system_time::checked_sub_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 2, ::core::option::Option::None)
    }
    pub fn get_duration_since_unix_epoch_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::system_time::get_duration_since_unix_epoch_params::Owned,crate::cap_std_capnp::system_time::get_duration_since_unix_epoch_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 3, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn duration_since(&self, _: DurationSinceParams<>, _: DurationSinceResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method system_time::Server::duration_since not implemented".to_string())) }
    async fn checked_add(&self, _: CheckedAddParams<>, _: CheckedAddResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method system_time::Server::checked_add not implemented".to_string())) }
    async fn checked_sub(&self, _: CheckedSubParams<>, _: CheckedSubResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method system_time::Server::checked_sub not implemented".to_string())) }
    async fn get_duration_since_unix_epoch(&self, _: GetDurationSinceUnixEpochParams<>, _: GetDurationSinceUnixEpochResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method system_time::Server::get_duration_since_unix_epoch not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.duration_since(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.checked_add(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          2 => server.checked_sub(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          3 => server.get_duration_since_unix_epoch(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xc3f0_b441_67ac_5ff3;
    pub static ENCODED_NODE: [::capnp::Word; 68] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(243, 95, 172, 103, 65, 180, 240, 195),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 178, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 7, 1, 0, 0),
      ::capnp::word(225, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
      ::capnp::word(109, 84, 105, 109, 101, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(16, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(90, 9, 142, 215, 19, 238, 56, 190),
      ::capnp::word(219, 4, 87, 138, 78, 195, 201, 159),
      ::capnp::word(113, 0, 0, 0, 114, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(105, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(218, 28, 128, 235, 141, 52, 234, 150),
      ::capnp::word(138, 122, 222, 229, 220, 60, 47, 142),
      ::capnp::word(93, 0, 0, 0, 90, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(85, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(222, 56, 193, 83, 165, 90, 54, 234),
      ::capnp::word(1, 147, 155, 141, 52, 157, 98, 135),
      ::capnp::word(73, 0, 0, 0, 90, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(65, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(64, 49, 184, 1, 186, 92, 158, 147),
      ::capnp::word(168, 153, 189, 114, 16, 51, 70, 128),
      ::capnp::word(53, 0, 0, 0, 210, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(53, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
      ::capnp::word(83, 105, 110, 99, 101, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 104, 101, 99, 107, 101, 100, 65),
      ::capnp::word(100, 100, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 104, 101, 99, 107, 101, 100, 83),
      ::capnp::word(117, 98, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(103, 101, 116, 68, 117, 114, 97, 116),
      ::capnp::word(105, 111, 110, 83, 105, 110, 99, 101),
      ::capnp::word(85, 110, 105, 120, 69, 112, 111, 99),
      ::capnp::word(104, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod duration_since_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_earlier(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_earlier(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_earlier(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_earlier(&mut self, value: crate::cap_std_capnp::system_time::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_earlier(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_earlier(&self) -> crate::cap_std_capnp::system_time::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(90, 9, 142, 215, 19, 238, 56, 190),
        ::capnp::word(54, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 90, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 84, 105, 109, 101, 46, 100, 117),
        ::capnp::word(114, 97, 116, 105, 111, 110, 83, 105),
        ::capnp::word(110, 99, 101, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(101, 97, 114, 108, 105, 101, 114, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(243, 95, 172, 103, 65, 180, 240, 195),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::system_time::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xbe38_ee13_d78e_095a;
    }
  }

  pub mod duration_since_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(219, 4, 87, 138, 78, 195, 201, 159),
        ::capnp::word(54, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 98, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 84, 105, 109, 101, 46, 100, 117),
        ::capnp::word(114, 97, 116, 105, 111, 110, 83, 105),
        ::capnp::word(110, 99, 101, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9fc9_c34e_8a57_04db;
    }
  }

  pub mod checked_add_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(218, 28, 128, 235, 141, 52, 234, 150),
        ::capnp::word(54, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 66, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 84, 105, 109, 101, 46, 99, 104),
        ::capnp::word(101, 99, 107, 101, 100, 65, 100, 100),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x96ea_348d_eb80_1cda;
    }
  }

  pub mod checked_add_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_result(&mut self, value: crate::cap_std_capnp::system_time::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_result(&self) -> crate::cap_std_capnp::system_time::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(138, 122, 222, 229, 220, 60, 47, 142),
        ::capnp::word(54, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 74, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 84, 105, 109, 101, 46, 99, 104),
        ::capnp::word(101, 99, 107, 101, 100, 65, 100, 100),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(243, 95, 172, 103, 65, 180, 240, 195),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::system_time::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8e2f_3cdc_e5de_7a8a;
    }
  }

  pub mod checked_sub_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(222, 56, 193, 83, 165, 90, 54, 234),
        ::capnp::word(54, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 66, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 84, 105, 109, 101, 46, 99, 104),
        ::capnp::word(101, 99, 107, 101, 100, 83, 117, 98),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xea36_5aa5_53c1_38de;
    }
  }

  pub mod checked_sub_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::system_time::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_result(&mut self, value: crate::cap_std_capnp::system_time::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_result(&self) -> crate::cap_std_capnp::system_time::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(1, 147, 155, 141, 52, 157, 98, 135),
        ::capnp::word(54, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 74, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 84, 105, 109, 101, 46, 99, 104),
        ::capnp::word(101, 99, 107, 101, 100, 83, 117, 98),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(243, 95, 172, 103, 65, 180, 240, 195),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::system_time::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8762_9d34_8d9b_9301;
    }
  }

  pub mod get_duration_since_unix_epoch_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(64, 49, 184, 1, 186, 92, 158, 147),
        ::capnp::word(54, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 186, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 84, 105, 109, 101, 46, 103, 101),
        ::capnp::word(116, 68, 117, 114, 97, 116, 105, 111),
        ::capnp::word(110, 83, 105, 110, 99, 101, 85, 110),
        ::capnp::word(105, 120, 69, 112, 111, 99, 104, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x939e_5cba_01b8_3140;
    }
  }

  pub mod get_duration_since_unix_epoch_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_duration(self) -> ::capnp::Result<crate::cap_std_capnp::duration::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_duration(&mut self, value: crate::cap_std_capnp::duration::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_duration(self, ) -> crate::cap_std_capnp::duration::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_duration(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_duration(&self) -> crate::cap_std_capnp::duration::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 40] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(168, 153, 189, 114, 16, 51, 70, 128),
        ::capnp::word(54, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 194, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 83, 121, 115, 116, 101),
        ::capnp::word(109, 84, 105, 109, 101, 46, 103, 101),
        ::capnp::word(116, 68, 117, 114, 97, 116, 105, 111),
        ::capnp::word(110, 83, 105, 110, 99, 101, 85, 110),
        ::capnp::word(105, 120, 69, 112, 111, 99, 104, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 117, 114, 97, 116, 105, 111, 110),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(168, 43, 54, 228, 132, 170, 243, 139),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::duration::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8046_3310_72bd_99a8;
    }
  }
}

#[repr(u16)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum FileType {
  Dir = 0,
  File = 1,
  Symlink = 2,
}

impl ::capnp::introspect::Introspect for FileType {
  fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Enum(::capnp::introspect::RawEnumSchema { encoded_node: &file_type::ENCODED_NODE, annotation_types: file_type::get_annotation_types }).into() }
}
impl <'a> ::core::convert::From<FileType> for ::capnp::dynamic_value::Reader<'a> {
  fn from(e: FileType) -> Self { ::capnp::dynamic_value::Enum::new(e.into(), ::capnp::introspect::RawEnumSchema { encoded_node: &file_type::ENCODED_NODE, annotation_types: file_type::get_annotation_types }.into()).into() }
}
impl ::core::convert::TryFrom<u16> for FileType {
  type Error = ::capnp::NotInSchema;
  fn try_from(value: u16) -> ::core::result::Result<Self, <FileType as ::core::convert::TryFrom<u16>>::Error> {
    match value {
      0 => ::core::result::Result::Ok(Self::Dir),
      1 => ::core::result::Result::Ok(Self::File),
      2 => ::core::result::Result::Ok(Self::Symlink),
      n => ::core::result::Result::Err(::capnp::NotInSchema(n)),
    }
  }
}
impl From<FileType> for u16 {
  #[inline]
  fn from(x: FileType) -> u16 { x as u16 }
}
impl ::capnp::traits::HasTypeId for FileType {
  const TYPE_ID: u64 = 0xa755_af25_d5f3_a42fu64;
}
mod file_type {
pub static ENCODED_NODE: [::capnp::Word; 33] = [
  ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
  ::capnp::word(47, 164, 243, 213, 37, 175, 85, 167),
  ::capnp::word(43, 0, 0, 0, 2, 0, 0, 0),
  ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 162, 1, 0, 0),
  ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(41, 0, 0, 0, 79, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
  ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
  ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
  ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
  ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
  ::capnp::word(110, 112, 58, 70, 105, 108, 101, 84),
  ::capnp::word(121, 112, 101, 0, 0, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
  ::capnp::word(12, 0, 0, 0, 1, 0, 2, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(29, 0, 0, 0, 34, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(21, 0, 0, 0, 42, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
  ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
  ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
  ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
  ::capnp::word(115, 121, 109, 108, 105, 110, 107, 0),
];
pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
  panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
}
}


pub mod read_dir {
  #![allow(unused_variables)]
  pub type NextParams<> = ::capnp::capability::Params<crate::cap_std_capnp::read_dir::next_params::Owned>;
  pub type NextResults<> = ::capnp::capability::Results<crate::cap_std_capnp::read_dir::next_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn next_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::read_dir::next_params::Owned,crate::cap_std_capnp::read_dir::next_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn next(&self, _: NextParams<>, _: NextResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method read_dir::Server::next not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.next(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xec65_ce2e_fc17_3ecf;
    pub static ENCODED_NODE: [::capnp::Word; 32] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(207, 62, 23, 252, 46, 206, 101, 236),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 154, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 71, 0, 0, 0),
      ::capnp::word(81, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 82, 101, 97, 100, 68),
      ::capnp::word(105, 114, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(4, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(238, 91, 138, 225, 179, 96, 70, 249),
      ::capnp::word(164, 13, 226, 185, 236, 215, 143, 178),
      ::capnp::word(17, 0, 0, 0, 42, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(5, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(110, 101, 120, 116, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod next_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(238, 91, 138, 225, 179, 96, 70, 249),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 82, 101, 97, 100, 68),
        ::capnp::word(105, 114, 46, 110, 101, 120, 116, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf946_60b3_e18a_5bee;
    }
  }

  pub mod next_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_entry(self) -> ::capnp::Result<crate::cap_std_capnp::dir_entry::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_entry(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_entry(self) -> ::capnp::Result<crate::cap_std_capnp::dir_entry::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_entry(&mut self, value: crate::cap_std_capnp::dir_entry::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_entry(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_entry(&self) -> crate::cap_std_capnp::dir_entry::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 36] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(164, 13, 226, 185, 236, 215, 143, 178),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 82, 101, 97, 100, 68),
        ::capnp::word(105, 114, 46, 110, 101, 120, 116, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 50, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(101, 110, 116, 114, 121, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(170, 50, 127, 170, 5, 45, 40, 197),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir_entry::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb28f_d7ec_b9e2_0da4;
    }
  }
}

pub mod open_options {
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
  impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

  pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
  impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
  impl <'a,> ::core::clone::Clone for Reader<'a,>  {
    fn clone(&self) -> Self { *self }
  }

  impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
    fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
      Self { reader,  }
    }
  }

  impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
    fn from(reader: Reader<'a,>) -> Self {
      Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
    }
  }

  impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
    fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
      core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
    }
  }

  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(reader.get_struct(default)?.into())
    }
  }

  impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
    fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
      self.reader
    }
  }

  impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
    fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
      self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
    }
  }

  impl <'a,> Reader<'a,>  {
    pub fn reborrow(&self) -> Reader<'_,> {
      Self { .. *self }
    }

    pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
      self.reader.total_size()
    }
    #[inline]
    pub fn get_read(self) -> bool {
      self.reader.get_bool_field(0)
    }
    #[inline]
    pub fn get_write(self) -> bool {
      self.reader.get_bool_field(1)
    }
    #[inline]
    pub fn get_append(self) -> bool {
      self.reader.get_bool_field(2)
    }
    #[inline]
    pub fn get_truncate(self) -> bool {
      self.reader.get_bool_field(3)
    }
    #[inline]
    pub fn get_create(self) -> bool {
      self.reader.get_bool_field(4)
    }
    #[inline]
    pub fn get_create_new(self) -> bool {
      self.reader.get_bool_field(5)
    }
  }

  pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
  impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
    const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
  }
  impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
    fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
      Self { builder,  }
    }
  }

  impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
    fn from(builder: Builder<'a,>) -> Self {
      Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
    }
  }

  impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
    fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
      self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
    }
  }

  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
    fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
    }
  }

  impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
  }

  impl <'a,> Builder<'a,>  {
    pub fn into_reader(self) -> Reader<'a,> {
      self.builder.into_reader().into()
    }
    pub fn reborrow(&mut self) -> Builder<'_,> {
      Builder { builder: self.builder.reborrow() }
    }
    pub fn reborrow_as_reader(&self) -> Reader<'_,> {
      self.builder.as_reader().into()
    }

    pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
      self.builder.as_reader().total_size()
    }
    #[inline]
    pub fn get_read(self) -> bool {
      self.builder.get_bool_field(0)
    }
    #[inline]
    pub fn set_read(&mut self, value: bool)  {
      self.builder.set_bool_field(0, value);
    }
    #[inline]
    pub fn get_write(self) -> bool {
      self.builder.get_bool_field(1)
    }
    #[inline]
    pub fn set_write(&mut self, value: bool)  {
      self.builder.set_bool_field(1, value);
    }
    #[inline]
    pub fn get_append(self) -> bool {
      self.builder.get_bool_field(2)
    }
    #[inline]
    pub fn set_append(&mut self, value: bool)  {
      self.builder.set_bool_field(2, value);
    }
    #[inline]
    pub fn get_truncate(self) -> bool {
      self.builder.get_bool_field(3)
    }
    #[inline]
    pub fn set_truncate(&mut self, value: bool)  {
      self.builder.set_bool_field(3, value);
    }
    #[inline]
    pub fn get_create(self) -> bool {
      self.builder.get_bool_field(4)
    }
    #[inline]
    pub fn set_create(&mut self, value: bool)  {
      self.builder.set_bool_field(4, value);
    }
    #[inline]
    pub fn get_create_new(self) -> bool {
      self.builder.get_bool_field(5)
    }
    #[inline]
    pub fn set_create_new(&mut self, value: bool)  {
      self.builder.set_bool_field(5, value);
    }
  }

  pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
  impl ::capnp::capability::FromTypelessPipeline for Pipeline {
    fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
      Self { _typeless: typeless,  }
    }
  }
  impl Pipeline  {
  }
  mod _private {
    pub static ENCODED_NODE: [::capnp::Word; 113] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(149, 85, 41, 169, 217, 167, 246, 184),
      ::capnp::word(43, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 186, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 87, 1, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 79, 112, 101, 110, 79),
      ::capnp::word(112, 116, 105, 111, 110, 115, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(24, 0, 0, 0, 3, 0, 4, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(153, 0, 0, 0, 42, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(148, 0, 0, 0, 3, 0, 1, 0),
      ::capnp::word(160, 0, 0, 0, 2, 0, 1, 0),
      ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
      ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(157, 0, 0, 0, 50, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(152, 0, 0, 0, 3, 0, 1, 0),
      ::capnp::word(164, 0, 0, 0, 2, 0, 1, 0),
      ::capnp::word(2, 0, 0, 0, 2, 0, 0, 0),
      ::capnp::word(0, 0, 1, 0, 2, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(161, 0, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(156, 0, 0, 0, 3, 0, 1, 0),
      ::capnp::word(168, 0, 0, 0, 2, 0, 1, 0),
      ::capnp::word(3, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(0, 0, 1, 0, 3, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(165, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(164, 0, 0, 0, 3, 0, 1, 0),
      ::capnp::word(176, 0, 0, 0, 2, 0, 1, 0),
      ::capnp::word(4, 0, 0, 0, 4, 0, 0, 0),
      ::capnp::word(0, 0, 1, 0, 4, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(173, 0, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(168, 0, 0, 0, 3, 0, 1, 0),
      ::capnp::word(180, 0, 0, 0, 2, 0, 1, 0),
      ::capnp::word(5, 0, 0, 0, 5, 0, 0, 0),
      ::capnp::word(0, 0, 1, 0, 5, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(177, 0, 0, 0, 82, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(176, 0, 0, 0, 3, 0, 1, 0),
      ::capnp::word(188, 0, 0, 0, 2, 0, 1, 0),
      ::capnp::word(114, 101, 97, 100, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(119, 114, 105, 116, 101, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(97, 112, 112, 101, 110, 100, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(116, 114, 117, 110, 99, 97, 116, 101),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(99, 114, 101, 97, 116, 101, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(99, 114, 101, 97, 116, 101, 78, 101),
      ::capnp::word(119, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
    ];
    pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
      match index {
        0 => <bool as ::capnp::introspect::Introspect>::introspect(),
        1 => <bool as ::capnp::introspect::Introspect>::introspect(),
        2 => <bool as ::capnp::introspect::Introspect>::introspect(),
        3 => <bool as ::capnp::introspect::Introspect>::introspect(),
        4 => <bool as ::capnp::introspect::Introspect>::introspect(),
        5 => <bool as ::capnp::introspect::Introspect>::introspect(),
        _ => panic!("invalid field index {}", index),
      }
    }
    pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
      panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
    }
    pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
      encoded_node: &ENCODED_NODE,
      nonunion_members: NONUNION_MEMBERS,
      members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
    };
    pub static NONUNION_MEMBERS : &[u16] = &[0,1,2,3,4,5];
    pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
    pub const TYPE_ID: u64 = 0xb8f6_a7d9_a929_5595;
  }
}


pub mod dir_entry {
  #![allow(unused_variables)]
  pub type OpenParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir_entry::open_params::Owned>;
  pub type OpenResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir_entry::open_results::Owned>;
  pub type OpenWithParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir_entry::open_with_params::Owned>;
  pub type OpenWithResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir_entry::open_with_results::Owned>;
  pub type OpenDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir_entry::open_dir_params::Owned>;
  pub type OpenDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir_entry::open_dir_results::Owned>;
  pub type RemoveFileParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir_entry::remove_file_params::Owned>;
  pub type RemoveFileResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir_entry::remove_file_results::Owned>;
  pub type RemoveDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir_entry::remove_dir_params::Owned>;
  pub type RemoveDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir_entry::remove_dir_results::Owned>;
  pub type MetadataParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir_entry::metadata_params::Owned>;
  pub type MetadataResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir_entry::metadata_results::Owned>;
  pub type FileTypeParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir_entry::file_type_params::Owned>;
  pub type FileTypeResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir_entry::file_type_results::Owned>;
  pub type FileNameParams<> = ::capnp::capability::Params<crate::cap_std_capnp::dir_entry::file_name_params::Owned>;
  pub type FileNameResults<> = ::capnp::capability::Results<crate::cap_std_capnp::dir_entry::file_name_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn open_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir_entry::open_params::Owned,crate::cap_std_capnp::dir_entry::open_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn open_with_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir_entry::open_with_params::Owned,crate::cap_std_capnp::dir_entry::open_with_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
    pub fn open_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir_entry::open_dir_params::Owned,crate::cap_std_capnp::dir_entry::open_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 2, ::core::option::Option::None)
    }
    pub fn remove_file_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir_entry::remove_file_params::Owned,crate::cap_std_capnp::dir_entry::remove_file_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 3, ::core::option::Option::None)
    }
    pub fn remove_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir_entry::remove_dir_params::Owned,crate::cap_std_capnp::dir_entry::remove_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 4, ::core::option::Option::None)
    }
    pub fn metadata_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir_entry::metadata_params::Owned,crate::cap_std_capnp::dir_entry::metadata_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 5, ::core::option::Option::None)
    }
    pub fn file_type_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir_entry::file_type_params::Owned,crate::cap_std_capnp::dir_entry::file_type_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 6, ::core::option::Option::None)
    }
    pub fn file_name_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::dir_entry::file_name_params::Owned,crate::cap_std_capnp::dir_entry::file_name_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 7, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn open(&self, _: OpenParams<>, _: OpenResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir_entry::Server::open not implemented".to_string())) }
    async fn open_with(&self, _: OpenWithParams<>, _: OpenWithResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir_entry::Server::open_with not implemented".to_string())) }
    async fn open_dir(&self, _: OpenDirParams<>, _: OpenDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir_entry::Server::open_dir not implemented".to_string())) }
    async fn remove_file(&self, _: RemoveFileParams<>, _: RemoveFileResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir_entry::Server::remove_file not implemented".to_string())) }
    async fn remove_dir(&self, _: RemoveDirParams<>, _: RemoveDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir_entry::Server::remove_dir not implemented".to_string())) }
    async fn metadata(&self, _: MetadataParams<>, _: MetadataResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir_entry::Server::metadata not implemented".to_string())) }
    async fn file_type(&self, _: FileTypeParams<>, _: FileTypeResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir_entry::Server::file_type not implemented".to_string())) }
    async fn file_name(&self, _: FileNameParams<>, _: FileNameResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method dir_entry::Server::file_name not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.open(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.open_with(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          2 => server.open_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          3 => server.remove_file(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          4 => server.remove_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          5 => server.metadata(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          6 => server.file_type(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          7 => server.file_name(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xc528_2d05_aa7f_32aa;
    pub static ENCODED_NODE: [::capnp::Word; 108] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(170, 50, 127, 170, 5, 45, 40, 197),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 162, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 7, 2, 0, 0),
      ::capnp::word(129, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
      ::capnp::word(116, 114, 121, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(32, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(33, 152, 97, 232, 158, 236, 41, 221),
      ::capnp::word(115, 186, 53, 118, 10, 39, 209, 244),
      ::capnp::word(241, 0, 0, 0, 42, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(229, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(78, 249, 250, 67, 191, 156, 172, 192),
      ::capnp::word(22, 200, 169, 234, 175, 171, 101, 197),
      ::capnp::word(217, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(209, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(206, 91, 51, 59, 12, 82, 240, 165),
      ::capnp::word(181, 185, 68, 17, 180, 111, 122, 147),
      ::capnp::word(197, 0, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(185, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(203, 102, 179, 232, 22, 138, 179, 226),
      ::capnp::word(92, 207, 42, 250, 254, 3, 199, 181),
      ::capnp::word(173, 0, 0, 0, 90, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(165, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(250, 64, 28, 72, 52, 202, 15, 206),
      ::capnp::word(106, 137, 53, 150, 86, 168, 2, 176),
      ::capnp::word(153, 0, 0, 0, 82, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(145, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(133, 95, 25, 112, 15, 53, 50, 182),
      ::capnp::word(199, 132, 45, 238, 214, 174, 25, 142),
      ::capnp::word(133, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(125, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(60, 35, 35, 191, 157, 200, 197, 163),
      ::capnp::word(38, 235, 193, 134, 110, 182, 111, 215),
      ::capnp::word(113, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(105, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(49, 153, 37, 77, 62, 69, 168, 227),
      ::capnp::word(26, 173, 2, 159, 156, 183, 120, 171),
      ::capnp::word(93, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(85, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(111, 112, 101, 110, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(111, 112, 101, 110, 87, 105, 116, 104),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(111, 112, 101, 110, 68, 105, 114, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 109, 111, 118, 101, 70, 105),
      ::capnp::word(108, 101, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 109, 111, 118, 101, 68, 105),
      ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(102, 105, 108, 101, 84, 121, 112, 101),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(102, 105, 108, 101, 78, 97, 109, 101),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod open_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(33, 152, 97, 232, 158, 236, 41, 221),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 111, 112, 101, 110),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xdd29_ec9e_e861_9821;
    }
  }

  pub mod open_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(115, 186, 53, 118, 10, 39, 209, 244),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 111, 112, 101, 110),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf4d1_270a_7635_ba73;
    }
  }

  pub mod open_with_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_open_options(self) -> ::capnp::Result<crate::cap_std_capnp::open_options::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_open_options(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_open_options(self) -> ::capnp::Result<crate::cap_std_capnp::open_options::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_open_options(&mut self, value: crate::cap_std_capnp::open_options::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(0), value, false)
      }
      #[inline]
      pub fn init_open_options(self, ) -> crate::cap_std_capnp::open_options::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(0), 0)
      }
      #[inline]
      pub fn has_open_options(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_open_options(&self) -> crate::cap_std_capnp::open_options::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(0))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(78, 249, 250, 67, 191, 156, 172, 192),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 111, 112, 101, 110),
        ::capnp::word(87, 105, 116, 104, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 98, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(111, 112, 101, 110, 79, 112, 116, 105),
        ::capnp::word(111, 110, 115, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(149, 85, 41, 169, 217, 167, 246, 184),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::open_options::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc0ac_9cbf_43fa_f94e;
    }
  }

  pub mod open_with_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(22, 200, 169, 234, 175, 171, 101, 197),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 111, 112, 101, 110),
        ::capnp::word(87, 105, 116, 104, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc565_abaf_eaa9_c816;
    }
  }

  pub mod open_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(206, 91, 51, 59, 12, 82, 240, 165),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 111, 112, 101, 110),
        ::capnp::word(68, 105, 114, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa5f0_520c_3b33_5bce;
    }
  }

  pub mod open_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(181, 185, 68, 17, 180, 111, 122, 147),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 111, 112, 101, 110),
        ::capnp::word(68, 105, 114, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x937a_6fb4_1144_b9b5;
    }
  }

  pub mod remove_file_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(203, 102, 179, 232, 22, 138, 179, 226),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 114, 101, 109, 111),
        ::capnp::word(118, 101, 70, 105, 108, 101, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe2b3_8a16_e8b3_66cb;
    }
  }

  pub mod remove_file_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(92, 207, 42, 250, 254, 3, 199, 181),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 58, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 114, 101, 109, 111),
        ::capnp::word(118, 101, 70, 105, 108, 101, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb5c7_03fe_fa2a_cf5c;
    }
  }

  pub mod remove_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(250, 64, 28, 72, 52, 202, 15, 206),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 114, 101, 109, 111),
        ::capnp::word(118, 101, 68, 105, 114, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xce0f_ca34_481c_40fa;
    }
  }

  pub mod remove_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(106, 137, 53, 150, 86, 168, 2, 176),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 114, 101, 109, 111),
        ::capnp::word(118, 101, 68, 105, 114, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb002_a856_9635_896a;
    }
  }

  pub mod metadata_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(133, 95, 25, 112, 15, 53, 50, 182),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 109, 101, 116, 97),
        ::capnp::word(100, 97, 116, 97, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb632_350f_7019_5f85;
    }
  }

  pub mod metadata_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_metadata(self) -> ::capnp::Result<crate::cap_std_capnp::metadata::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_metadata(&mut self, value: crate::cap_std_capnp::metadata::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_metadata(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_metadata(&self) -> crate::cap_std_capnp::metadata::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(199, 132, 45, 238, 214, 174, 25, 142),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 109, 101, 116, 97),
        ::capnp::word(100, 97, 116, 97, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(109, 101, 116, 97, 100, 97, 116, 97),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 146, 247, 39, 247, 32, 193, 202),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::metadata::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8e19_aed6_ee2d_84c7;
    }
  }

  pub mod file_type_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(60, 35, 35, 191, 157, 200, 197, 163),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 102, 105, 108, 101),
        ::capnp::word(84, 121, 112, 101, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa3c5_c89d_bf23_233c;
    }
  }

  pub mod file_type_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_type(self) -> ::core::result::Result<crate::cap_std_capnp::FileType,::capnp::NotInSchema> {
        ::core::convert::TryInto::try_into(self.reader.get_data_field::<u16>(0))
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 1, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_type(self) -> ::core::result::Result<crate::cap_std_capnp::FileType,::capnp::NotInSchema> {
        ::core::convert::TryInto::try_into(self.builder.get_data_field::<u16>(0))
      }
      #[inline]
      pub fn set_type(&mut self, value: crate::cap_std_capnp::FileType)  {
        self.builder.set_data_field::<u16>(0, value as u16);
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(38, 235, 193, 134, 110, 182, 111, 215),
        ::capnp::word(52, 0, 0, 0, 1, 0, 1, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 102, 105, 108, 101),
        ::capnp::word(84, 121, 112, 101, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(116, 121, 112, 101, 0, 0, 0, 0),
        ::capnp::word(15, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(47, 164, 243, 213, 37, 175, 85, 167),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(15, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::FileType as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd76f_b66e_86c1_eb26;
    }
  }

  pub mod file_name_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(49, 153, 37, 77, 62, 69, 168, 227),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 102, 105, 108, 101),
        ::capnp::word(78, 97, 109, 101, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe3a8_453e_4d25_9931;
    }
  }

  pub mod file_name_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_result(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_result(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(26, 173, 2, 159, 156, 183, 120, 171),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 42, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 68, 105, 114, 69, 110),
        ::capnp::word(116, 114, 121, 46, 102, 105, 108, 101),
        ::capnp::word(78, 97, 109, 101, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xab78_b79c_9f02_ad1a;
    }
  }
}


pub mod ambient_authority {
  #![allow(unused_variables)]
  pub type FileOpenAmbientParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::file_open_ambient_params::Owned>;
  pub type FileOpenAmbientResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::file_open_ambient_results::Owned>;
  pub type FileCreateAmbientParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::file_create_ambient_params::Owned>;
  pub type FileCreateAmbientResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::file_create_ambient_results::Owned>;
  pub type FileOpenAmbientWithParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::file_open_ambient_with_params::Owned>;
  pub type FileOpenAmbientWithResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::file_open_ambient_with_results::Owned>;
  pub type DirOpenAmbientParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::dir_open_ambient_params::Owned>;
  pub type DirOpenAmbientResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::dir_open_ambient_results::Owned>;
  pub type DirOpenParentParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::dir_open_parent_params::Owned>;
  pub type DirOpenParentResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::dir_open_parent_results::Owned>;
  pub type DirCreateAmbientAllParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::dir_create_ambient_all_params::Owned>;
  pub type DirCreateAmbientAllResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::dir_create_ambient_all_results::Owned>;
  pub type MonotonicClockNewParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::monotonic_clock_new_params::Owned>;
  pub type MonotonicClockNewResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::monotonic_clock_new_results::Owned>;
  pub type SystemClockNewParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::system_clock_new_params::Owned>;
  pub type SystemClockNewResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::system_clock_new_results::Owned>;
  pub type ProjectDirsFromParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::project_dirs_from_params::Owned>;
  pub type ProjectDirsFromResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::project_dirs_from_results::Owned>;
  pub type UserDirsHomeDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_home_dir_params::Owned>;
  pub type UserDirsHomeDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_home_dir_results::Owned>;
  pub type UserDirsAudioDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_audio_dir_params::Owned>;
  pub type UserDirsAudioDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_audio_dir_results::Owned>;
  pub type UserDirsDesktopDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_desktop_dir_params::Owned>;
  pub type UserDirsDesktopDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_desktop_dir_results::Owned>;
  pub type UserDirsDocumentDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_document_dir_params::Owned>;
  pub type UserDirsDocumentDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_document_dir_results::Owned>;
  pub type UserDirsDownloadDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_download_dir_params::Owned>;
  pub type UserDirsDownloadDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_download_dir_results::Owned>;
  pub type UserDirsFontDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_font_dir_params::Owned>;
  pub type UserDirsFontDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_font_dir_results::Owned>;
  pub type UserDirsPictureDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_picture_dir_params::Owned>;
  pub type UserDirsPictureDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_picture_dir_results::Owned>;
  pub type UserDirsPublicDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_public_dir_params::Owned>;
  pub type UserDirsPublicDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_public_dir_results::Owned>;
  pub type UserDirsTemplateDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_template_dir_params::Owned>;
  pub type UserDirsTemplateDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_template_dir_results::Owned>;
  pub type UserDirsVideoDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::user_dirs_video_dir_params::Owned>;
  pub type UserDirsVideoDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::user_dirs_video_dir_results::Owned>;
  pub type TempDirNewParams<> = ::capnp::capability::Params<crate::cap_std_capnp::ambient_authority::temp_dir_new_params::Owned>;
  pub type TempDirNewResults<> = ::capnp::capability::Results<crate::cap_std_capnp::ambient_authority::temp_dir_new_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn file_open_ambient_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::file_open_ambient_params::Owned,crate::cap_std_capnp::ambient_authority::file_open_ambient_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn file_create_ambient_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::file_create_ambient_params::Owned,crate::cap_std_capnp::ambient_authority::file_create_ambient_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
    pub fn file_open_ambient_with_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::file_open_ambient_with_params::Owned,crate::cap_std_capnp::ambient_authority::file_open_ambient_with_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 2, ::core::option::Option::None)
    }
    pub fn dir_open_ambient_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::dir_open_ambient_params::Owned,crate::cap_std_capnp::ambient_authority::dir_open_ambient_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 3, ::core::option::Option::None)
    }
    pub fn dir_open_parent_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::dir_open_parent_params::Owned,crate::cap_std_capnp::ambient_authority::dir_open_parent_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 4, ::core::option::Option::None)
    }
    pub fn dir_create_ambient_all_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::dir_create_ambient_all_params::Owned,crate::cap_std_capnp::ambient_authority::dir_create_ambient_all_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 5, ::core::option::Option::None)
    }
    pub fn monotonic_clock_new_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::monotonic_clock_new_params::Owned,crate::cap_std_capnp::ambient_authority::monotonic_clock_new_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 6, ::core::option::Option::None)
    }
    pub fn system_clock_new_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::system_clock_new_params::Owned,crate::cap_std_capnp::ambient_authority::system_clock_new_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 7, ::core::option::Option::None)
    }
    pub fn project_dirs_from_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::project_dirs_from_params::Owned,crate::cap_std_capnp::ambient_authority::project_dirs_from_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 8, ::core::option::Option::None)
    }
    pub fn user_dirs_home_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_home_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_home_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 9, ::core::option::Option::None)
    }
    pub fn user_dirs_audio_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_audio_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_audio_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 10, ::core::option::Option::None)
    }
    pub fn user_dirs_desktop_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_desktop_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_desktop_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 11, ::core::option::Option::None)
    }
    pub fn user_dirs_document_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_document_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_document_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 12, ::core::option::Option::None)
    }
    pub fn user_dirs_download_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_download_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_download_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 13, ::core::option::Option::None)
    }
    pub fn user_dirs_font_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_font_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_font_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 14, ::core::option::Option::None)
    }
    pub fn user_dirs_picture_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_picture_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_picture_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 15, ::core::option::Option::None)
    }
    pub fn user_dirs_public_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_public_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_public_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 16, ::core::option::Option::None)
    }
    pub fn user_dirs_template_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_template_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_template_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 17, ::core::option::Option::None)
    }
    pub fn user_dirs_video_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::user_dirs_video_dir_params::Owned,crate::cap_std_capnp::ambient_authority::user_dirs_video_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 18, ::core::option::Option::None)
    }
    pub fn temp_dir_new_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::ambient_authority::temp_dir_new_params::Owned,crate::cap_std_capnp::ambient_authority::temp_dir_new_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 19, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn file_open_ambient(&self, _: FileOpenAmbientParams<>, _: FileOpenAmbientResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::file_open_ambient not implemented".to_string())) }
    async fn file_create_ambient(&self, _: FileCreateAmbientParams<>, _: FileCreateAmbientResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::file_create_ambient not implemented".to_string())) }
    async fn file_open_ambient_with(&self, _: FileOpenAmbientWithParams<>, _: FileOpenAmbientWithResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::file_open_ambient_with not implemented".to_string())) }
    async fn dir_open_ambient(&self, _: DirOpenAmbientParams<>, _: DirOpenAmbientResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::dir_open_ambient not implemented".to_string())) }
    async fn dir_open_parent(&self, _: DirOpenParentParams<>, _: DirOpenParentResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::dir_open_parent not implemented".to_string())) }
    async fn dir_create_ambient_all(&self, _: DirCreateAmbientAllParams<>, _: DirCreateAmbientAllResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::dir_create_ambient_all not implemented".to_string())) }
    async fn monotonic_clock_new(&self, _: MonotonicClockNewParams<>, _: MonotonicClockNewResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::monotonic_clock_new not implemented".to_string())) }
    async fn system_clock_new(&self, _: SystemClockNewParams<>, _: SystemClockNewResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::system_clock_new not implemented".to_string())) }
    async fn project_dirs_from(&self, _: ProjectDirsFromParams<>, _: ProjectDirsFromResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::project_dirs_from not implemented".to_string())) }
    async fn user_dirs_home_dir(&self, _: UserDirsHomeDirParams<>, _: UserDirsHomeDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_home_dir not implemented".to_string())) }
    async fn user_dirs_audio_dir(&self, _: UserDirsAudioDirParams<>, _: UserDirsAudioDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_audio_dir not implemented".to_string())) }
    async fn user_dirs_desktop_dir(&self, _: UserDirsDesktopDirParams<>, _: UserDirsDesktopDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_desktop_dir not implemented".to_string())) }
    async fn user_dirs_document_dir(&self, _: UserDirsDocumentDirParams<>, _: UserDirsDocumentDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_document_dir not implemented".to_string())) }
    async fn user_dirs_download_dir(&self, _: UserDirsDownloadDirParams<>, _: UserDirsDownloadDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_download_dir not implemented".to_string())) }
    async fn user_dirs_font_dir(&self, _: UserDirsFontDirParams<>, _: UserDirsFontDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_font_dir not implemented".to_string())) }
    async fn user_dirs_picture_dir(&self, _: UserDirsPictureDirParams<>, _: UserDirsPictureDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_picture_dir not implemented".to_string())) }
    async fn user_dirs_public_dir(&self, _: UserDirsPublicDirParams<>, _: UserDirsPublicDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_public_dir not implemented".to_string())) }
    async fn user_dirs_template_dir(&self, _: UserDirsTemplateDirParams<>, _: UserDirsTemplateDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_template_dir not implemented".to_string())) }
    async fn user_dirs_video_dir(&self, _: UserDirsVideoDirParams<>, _: UserDirsVideoDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::user_dirs_video_dir not implemented".to_string())) }
    async fn temp_dir_new(&self, _: TempDirNewParams<>, _: TempDirNewResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method ambient_authority::Server::temp_dir_new not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.file_open_ambient(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.file_create_ambient(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          2 => server.file_open_ambient_with(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          3 => server.dir_open_ambient(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          4 => server.dir_open_parent(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          5 => server.dir_create_ambient_all(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          6 => server.monotonic_clock_new(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          7 => server.system_clock_new(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          8 => server.project_dirs_from(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          9 => server.user_dirs_home_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          10 => server.user_dirs_audio_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          11 => server.user_dirs_desktop_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          12 => server.user_dirs_document_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          13 => server.user_dirs_download_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          14 => server.user_dirs_font_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          15 => server.user_dirs_picture_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          16 => server.user_dirs_public_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          17 => server.user_dirs_template_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          18 => server.user_dirs_video_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          19 => server.temp_dir_new(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xedfb_7fe3_b145_e6a0;
    pub static ENCODED_NODE: [::capnp::Word; 255] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(160, 230, 69, 177, 227, 127, 251, 237),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 226, 1, 0, 0),
      ::capnp::word(49, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 5, 0, 0),
      ::capnp::word(205, 3, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
      ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
      ::capnp::word(105, 116, 121, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(80, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(239, 68, 158, 75, 126, 182, 98, 153),
      ::capnp::word(104, 215, 64, 6, 28, 156, 91, 210),
      ::capnp::word(113, 2, 0, 0, 130, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(105, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(236, 179, 147, 131, 163, 133, 27, 235),
      ::capnp::word(17, 163, 188, 165, 244, 210, 86, 141),
      ::capnp::word(93, 2, 0, 0, 146, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(89, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(8, 166, 252, 127, 236, 45, 109, 244),
      ::capnp::word(210, 102, 46, 50, 181, 162, 74, 250),
      ::capnp::word(77, 2, 0, 0, 162, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(73, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(252, 60, 105, 167, 111, 89, 239, 191),
      ::capnp::word(97, 9, 247, 142, 108, 181, 75, 170),
      ::capnp::word(61, 2, 0, 0, 122, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(53, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(143, 55, 48, 4, 78, 109, 164, 240),
      ::capnp::word(243, 162, 146, 27, 41, 49, 130, 186),
      ::capnp::word(41, 2, 0, 0, 114, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(33, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(5, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(225, 74, 84, 98, 227, 166, 106, 144),
      ::capnp::word(231, 45, 192, 187, 42, 129, 84, 226),
      ::capnp::word(21, 2, 0, 0, 162, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(17, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(6, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(150, 195, 43, 101, 226, 107, 8, 176),
      ::capnp::word(37, 129, 109, 122, 85, 240, 255, 234),
      ::capnp::word(5, 2, 0, 0, 146, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(1, 2, 0, 0, 7, 0, 0, 0),
      ::capnp::word(7, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(174, 125, 141, 244, 160, 241, 145, 224),
      ::capnp::word(141, 172, 46, 211, 160, 114, 45, 130),
      ::capnp::word(245, 1, 0, 0, 122, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(237, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(8, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(219, 199, 106, 27, 1, 51, 250, 175),
      ::capnp::word(35, 177, 124, 200, 80, 110, 216, 192),
      ::capnp::word(225, 1, 0, 0, 130, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(217, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(9, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(146, 235, 232, 228, 120, 80, 65, 155),
      ::capnp::word(82, 203, 105, 27, 32, 180, 12, 248),
      ::capnp::word(205, 1, 0, 0, 130, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(197, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(10, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(155, 242, 103, 219, 93, 70, 94, 239),
      ::capnp::word(152, 17, 143, 199, 227, 99, 200, 185),
      ::capnp::word(185, 1, 0, 0, 138, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(181, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(11, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(155, 53, 215, 139, 6, 233, 231, 139),
      ::capnp::word(178, 231, 17, 180, 29, 90, 15, 129),
      ::capnp::word(169, 1, 0, 0, 154, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(165, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(71, 50, 8, 107, 63, 201, 166, 154),
      ::capnp::word(81, 135, 110, 8, 77, 44, 112, 193),
      ::capnp::word(153, 1, 0, 0, 162, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(149, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(13, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(101, 135, 139, 105, 104, 162, 183, 255),
      ::capnp::word(149, 16, 226, 223, 25, 89, 101, 229),
      ::capnp::word(137, 1, 0, 0, 162, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(133, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(14, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(255, 129, 107, 188, 240, 91, 228, 152),
      ::capnp::word(7, 123, 5, 57, 137, 28, 134, 242),
      ::capnp::word(121, 1, 0, 0, 130, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(113, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(15, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(162, 191, 1, 149, 154, 217, 28, 194),
      ::capnp::word(119, 147, 64, 243, 53, 52, 59, 231),
      ::capnp::word(101, 1, 0, 0, 154, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(97, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(32, 6, 169, 49, 222, 76, 142, 154),
      ::capnp::word(238, 241, 181, 245, 219, 127, 77, 167),
      ::capnp::word(85, 1, 0, 0, 146, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(81, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(188, 184, 118, 225, 57, 57, 224, 220),
      ::capnp::word(80, 103, 53, 246, 180, 221, 32, 156),
      ::capnp::word(69, 1, 0, 0, 162, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(65, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(18, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(48, 73, 60, 196, 244, 99, 244, 250),
      ::capnp::word(39, 106, 35, 201, 49, 129, 99, 216),
      ::capnp::word(53, 1, 0, 0, 138, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(49, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(19, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(29, 199, 229, 244, 238, 88, 5, 223),
      ::capnp::word(23, 190, 189, 21, 238, 145, 30, 132),
      ::capnp::word(37, 1, 0, 0, 90, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(29, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(102, 105, 108, 101, 79, 112, 101, 110),
      ::capnp::word(65, 109, 98, 105, 101, 110, 116, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(102, 105, 108, 101, 67, 114, 101, 97),
      ::capnp::word(116, 101, 65, 109, 98, 105, 101, 110),
      ::capnp::word(116, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(102, 105, 108, 101, 79, 112, 101, 110),
      ::capnp::word(65, 109, 98, 105, 101, 110, 116, 87),
      ::capnp::word(105, 116, 104, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(100, 105, 114, 79, 112, 101, 110, 65),
      ::capnp::word(109, 98, 105, 101, 110, 116, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(100, 105, 114, 79, 112, 101, 110, 80),
      ::capnp::word(97, 114, 101, 110, 116, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(100, 105, 114, 67, 114, 101, 97, 116),
      ::capnp::word(101, 65, 109, 98, 105, 101, 110, 116),
      ::capnp::word(65, 108, 108, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(109, 111, 110, 111, 116, 111, 110, 105),
      ::capnp::word(99, 67, 108, 111, 99, 107, 78, 101),
      ::capnp::word(119, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(115, 121, 115, 116, 101, 109, 67, 108),
      ::capnp::word(111, 99, 107, 78, 101, 119, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(112, 114, 111, 106, 101, 99, 116, 68),
      ::capnp::word(105, 114, 115, 70, 114, 111, 109, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(72, 111, 109, 101, 68, 105, 114, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(65, 117, 100, 105, 111, 68, 105, 114),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(68, 101, 115, 107, 116, 111, 112, 68),
      ::capnp::word(105, 114, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(68, 111, 99, 117, 109, 101, 110, 116),
      ::capnp::word(68, 105, 114, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(68, 111, 119, 110, 108, 111, 97, 100),
      ::capnp::word(68, 105, 114, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(70, 111, 110, 116, 68, 105, 114, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(80, 105, 99, 116, 117, 114, 101, 68),
      ::capnp::word(105, 114, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(80, 117, 98, 108, 105, 99, 68, 105),
      ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(84, 101, 109, 112, 108, 97, 116, 101),
      ::capnp::word(68, 105, 114, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
      ::capnp::word(86, 105, 100, 101, 111, 68, 105, 114),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(116, 101, 109, 112, 68, 105, 114, 78),
      ::capnp::word(101, 119, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod file_open_ambient_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(239, 68, 158, 75, 126, 182, 98, 153),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 154, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 102, 105, 108, 101),
        ::capnp::word(79, 112, 101, 110, 65, 109, 98, 105),
        ::capnp::word(101, 110, 116, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9962_b67e_4b9e_44ef;
    }
  }

  pub mod file_open_ambient_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(104, 215, 64, 6, 28, 156, 91, 210),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 162, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 102, 105, 108, 101),
        ::capnp::word(79, 112, 101, 110, 65, 109, 98, 105),
        ::capnp::word(101, 110, 116, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd25b_9c1c_0640_d768;
    }
  }

  pub mod file_create_ambient_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(236, 179, 147, 131, 163, 133, 27, 235),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 170, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 102, 105, 108, 101),
        ::capnp::word(67, 114, 101, 97, 116, 101, 65, 109),
        ::capnp::word(98, 105, 101, 110, 116, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xeb1b_85a3_8393_b3ec;
    }
  }

  pub mod file_create_ambient_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(17, 163, 188, 165, 244, 210, 86, 141),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 178, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 102, 105, 108, 101),
        ::capnp::word(67, 114, 101, 97, 116, 101, 65, 109),
        ::capnp::word(98, 105, 101, 110, 116, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8d56_d2f4_a5bc_a311;
    }
  }

  pub mod file_open_ambient_with_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_open_options(self) -> ::capnp::Result<crate::cap_std_capnp::open_options::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_open_options(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 2 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_open_options(self) -> ::capnp::Result<crate::cap_std_capnp::open_options::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_open_options(&mut self, value: crate::cap_std_capnp::open_options::Reader<'_>) -> ::capnp::Result<()> {
        ::capnp::traits::SetPointerBuilder::set_pointer_builder(self.builder.reborrow().get_pointer_field(1), value, false)
      }
      #[inline]
      pub fn init_open_options(self, ) -> crate::cap_std_capnp::open_options::Builder<'a> {
        ::capnp::traits::FromPointerBuilder::init_pointer(self.builder.get_pointer_field(1), 0)
      }
      #[inline]
      pub fn has_open_options(&self) -> bool {
        !self.builder.is_pointer_field_null(1)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_open_options(&self) -> crate::cap_std_capnp::open_options::Pipeline {
        ::capnp::capability::FromTypelessPipeline::new(self._typeless.get_pointer_field(1))
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 55] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(8, 166, 252, 127, 236, 45, 109, 244),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(2, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 186, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 119, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 102, 105, 108, 101),
        ::capnp::word(79, 112, 101, 110, 65, 109, 98, 105),
        ::capnp::word(101, 110, 116, 87, 105, 116, 104, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(36, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(48, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 98, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(44, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(56, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(111, 112, 101, 110, 79, 112, 116, 105),
        ::capnp::word(111, 110, 115, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(149, 85, 41, 169, 217, 167, 246, 184),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(16, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <crate::cap_std_capnp::open_options::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf46d_2dec_7ffc_a608;
    }
  }

  pub mod file_open_ambient_with_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(210, 102, 46, 50, 181, 162, 74, 250),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 194, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 102, 105, 108, 101),
        ::capnp::word(79, 112, 101, 110, 65, 109, 98, 105),
        ::capnp::word(101, 110, 116, 87, 105, 116, 104, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xfa4a_a2b5_322e_66d2;
    }
  }

  pub mod dir_open_ambient_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(252, 60, 105, 167, 111, 89, 239, 191),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 146, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 100, 105, 114, 79),
        ::capnp::word(112, 101, 110, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xbfef_596f_a769_3cfc;
    }
  }

  pub mod dir_open_ambient_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_result(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_result(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(97, 9, 247, 142, 108, 181, 75, 170),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 154, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 100, 105, 114, 79),
        ::capnp::word(112, 101, 110, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xaa4b_b56c_8ef7_0961;
    }
  }

  pub mod dir_open_parent_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(143, 55, 48, 4, 78, 109, 164, 240),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 138, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 100, 105, 114, 79),
        ::capnp::word(112, 101, 110, 80, 97, 114, 101, 110),
        ::capnp::word(116, 36, 80, 97, 114, 97, 109, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf0a4_6d4e_0430_378f;
    }
  }

  pub mod dir_open_parent_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_result(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_result(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_result(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_result(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(243, 162, 146, 27, 41, 49, 130, 186),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 146, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 100, 105, 114, 79),
        ::capnp::word(112, 101, 110, 80, 97, 114, 101, 110),
        ::capnp::word(116, 36, 82, 101, 115, 117, 108, 116),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 58, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(114, 101, 115, 117, 108, 116, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xba82_3129_1b92_a2f3;
    }
  }

  pub mod dir_create_ambient_all_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_path(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_path(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_path(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_path(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(225, 74, 84, 98, 227, 166, 106, 144),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 186, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 100, 105, 114, 67),
        ::capnp::word(114, 101, 97, 116, 101, 65, 109, 98),
        ::capnp::word(105, 101, 110, 116, 65, 108, 108, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 97, 116, 104, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x906a_a6e3_6254_4ae1;
    }
  }

  pub mod dir_create_ambient_all_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(231, 45, 192, 187, 42, 129, 84, 226),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 194, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 100, 105, 114, 67),
        ::capnp::word(114, 101, 97, 116, 101, 65, 109, 98),
        ::capnp::word(105, 101, 110, 116, 65, 108, 108, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe254_812a_bbc0_2de7;
    }
  }

  pub mod monotonic_clock_new_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(150, 195, 43, 101, 226, 107, 8, 176),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 170, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 109, 111, 110, 111),
        ::capnp::word(116, 111, 110, 105, 99, 67, 108, 111),
        ::capnp::word(99, 107, 78, 101, 119, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb008_6be2_652b_c396;
    }
  }

  pub mod monotonic_clock_new_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_clock(self) -> ::capnp::Result<crate::cap_std_capnp::monotonic_clock::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_clock(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_clock(self) -> ::capnp::Result<crate::cap_std_capnp::monotonic_clock::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_clock(&mut self, value: crate::cap_std_capnp::monotonic_clock::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_clock(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_clock(&self) -> crate::cap_std_capnp::monotonic_clock::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(37, 129, 109, 122, 85, 240, 255, 234),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 178, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 109, 111, 110, 111),
        ::capnp::word(116, 111, 110, 105, 99, 67, 108, 111),
        ::capnp::word(99, 107, 78, 101, 119, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 50, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(99, 108, 111, 99, 107, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(101, 80, 45, 18, 214, 155, 42, 153),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::monotonic_clock::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xeaff_f055_7a6d_8125;
    }
  }

  pub mod system_clock_new_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(174, 125, 141, 244, 160, 241, 145, 224),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 146, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 115, 121, 115, 116),
        ::capnp::word(101, 109, 67, 108, 111, 99, 107, 78),
        ::capnp::word(101, 119, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe091_f1a0_f48d_7dae;
    }
  }

  pub mod system_clock_new_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_clock(self) -> ::capnp::Result<crate::cap_std_capnp::system_clock::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_clock(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_clock(self) -> ::capnp::Result<crate::cap_std_capnp::system_clock::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_clock(&mut self, value: crate::cap_std_capnp::system_clock::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_clock(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_clock(&self) -> crate::cap_std_capnp::system_clock::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(141, 172, 46, 211, 160, 114, 45, 130),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 154, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 115, 121, 115, 116),
        ::capnp::word(101, 109, 67, 108, 111, 99, 107, 78),
        ::capnp::word(101, 119, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 50, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(99, 108, 111, 99, 107, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(200, 191, 27, 252, 155, 43, 56, 158),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::system_clock::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x822d_72a0_d32e_ac8d;
    }
  }

  pub mod project_dirs_from_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_qualifier(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_qualifier(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
      #[inline]
      pub fn get_organization(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_organization(&self) -> bool {
        !self.reader.get_pointer_field(1).is_null()
      }
      #[inline]
      pub fn get_application(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(2), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_application(&self) -> bool {
        !self.reader.get_pointer_field(2).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 3 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_qualifier(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_qualifier(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_qualifier(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_qualifier(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
      #[inline]
      pub fn get_organization(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(1), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_organization(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(1).set_text(value);
      }
      #[inline]
      pub fn init_organization(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(1).init_text(size)
      }
      #[inline]
      pub fn has_organization(&self) -> bool {
        !self.builder.is_pointer_field_null(1)
      }
      #[inline]
      pub fn get_application(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(2), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_application(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(2).set_text(value);
      }
      #[inline]
      pub fn init_application(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(2).init_text(size)
      }
      #[inline]
      pub fn has_application(&self) -> bool {
        !self.builder.is_pointer_field_null(2)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 72] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(219, 199, 106, 27, 1, 51, 250, 175),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(3, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 154, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 175, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 112, 114, 111, 106),
        ::capnp::word(101, 99, 116, 68, 105, 114, 115, 70),
        ::capnp::word(114, 111, 109, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(69, 0, 0, 0, 82, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(68, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(80, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(1, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(77, 0, 0, 0, 106, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(76, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(88, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(2, 0, 0, 0, 2, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 2, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(85, 0, 0, 0, 98, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(84, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(96, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(113, 117, 97, 108, 105, 102, 105, 101),
        ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(111, 114, 103, 97, 110, 105, 122, 97),
        ::capnp::word(116, 105, 111, 110, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(97, 112, 112, 108, 105, 99, 97, 116),
        ::capnp::word(105, 111, 110, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          1 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          2 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0,1,2];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xaffa_3301_1b6a_c7db;
    }
  }

  pub mod project_dirs_from_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_project_dirs(self) -> ::capnp::Result<crate::cap_std_capnp::project_dirs::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_project_dirs(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_project_dirs(self) -> ::capnp::Result<crate::cap_std_capnp::project_dirs::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_project_dirs(&mut self, value: crate::cap_std_capnp::project_dirs::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_project_dirs(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_project_dirs(&self) -> crate::cap_std_capnp::project_dirs::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 40] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(35, 177, 124, 200, 80, 110, 216, 192),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 162, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 112, 114, 111, 106),
        ::capnp::word(101, 99, 116, 68, 105, 114, 115, 70),
        ::capnp::word(114, 111, 109, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 98, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(112, 114, 111, 106, 101, 99, 116, 68),
        ::capnp::word(105, 114, 115, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(186, 59, 64, 108, 159, 189, 26, 185),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::project_dirs::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc0d8_6e50_c87c_b123;
    }
  }

  pub mod user_dirs_home_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(146, 235, 232, 228, 120, 80, 65, 155),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 154, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 72, 111, 109, 101),
        ::capnp::word(68, 105, 114, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9b41_5078_e4e8_eb92;
    }
  }

  pub mod user_dirs_home_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(82, 203, 105, 27, 32, 180, 12, 248),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 162, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 72, 111, 109, 101),
        ::capnp::word(68, 105, 114, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf80c_b420_1b69_cb52;
    }
  }

  pub mod user_dirs_audio_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(155, 242, 103, 219, 93, 70, 94, 239),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 162, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 65, 117, 100, 105),
        ::capnp::word(111, 68, 105, 114, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xef5e_465d_db67_f29b;
    }
  }

  pub mod user_dirs_audio_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(152, 17, 143, 199, 227, 99, 200, 185),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 170, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 65, 117, 100, 105),
        ::capnp::word(111, 68, 105, 114, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb9c8_63e3_c78f_1198;
    }
  }

  pub mod user_dirs_desktop_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(155, 53, 215, 139, 6, 233, 231, 139),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 178, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 68, 101, 115, 107),
        ::capnp::word(116, 111, 112, 68, 105, 114, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x8be7_e906_8bd7_359b;
    }
  }

  pub mod user_dirs_desktop_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(178, 231, 17, 180, 29, 90, 15, 129),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 186, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 68, 101, 115, 107),
        ::capnp::word(116, 111, 112, 68, 105, 114, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x810f_5a1d_b411_e7b2;
    }
  }

  pub mod user_dirs_document_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(71, 50, 8, 107, 63, 201, 166, 154),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 186, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 68, 111, 99, 117),
        ::capnp::word(109, 101, 110, 116, 68, 105, 114, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9aa6_c93f_6b08_3247;
    }
  }

  pub mod user_dirs_document_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(81, 135, 110, 8, 77, 44, 112, 193),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 194, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 68, 111, 99, 117),
        ::capnp::word(109, 101, 110, 116, 68, 105, 114, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc170_2c4d_086e_8751;
    }
  }

  pub mod user_dirs_download_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(101, 135, 139, 105, 104, 162, 183, 255),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 186, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 68, 111, 119, 110),
        ::capnp::word(108, 111, 97, 100, 68, 105, 114, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xffb7_a268_698b_8765;
    }
  }

  pub mod user_dirs_download_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(149, 16, 226, 223, 25, 89, 101, 229),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 194, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 68, 111, 119, 110),
        ::capnp::word(108, 111, 97, 100, 68, 105, 114, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe565_5919_dfe2_1095;
    }
  }

  pub mod user_dirs_font_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(255, 129, 107, 188, 240, 91, 228, 152),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 154, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 70, 111, 110, 116),
        ::capnp::word(68, 105, 114, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x98e4_5bf0_bc6b_81ff;
    }
  }

  pub mod user_dirs_font_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(7, 123, 5, 57, 137, 28, 134, 242),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 162, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 70, 111, 110, 116),
        ::capnp::word(68, 105, 114, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf286_1c89_3905_7b07;
    }
  }

  pub mod user_dirs_picture_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(162, 191, 1, 149, 154, 217, 28, 194),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 178, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 80, 105, 99, 116),
        ::capnp::word(117, 114, 101, 68, 105, 114, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc21c_d99a_9501_bfa2;
    }
  }

  pub mod user_dirs_picture_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(119, 147, 64, 243, 53, 52, 59, 231),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 186, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 80, 105, 99, 116),
        ::capnp::word(117, 114, 101, 68, 105, 114, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xe73b_3435_f340_9377;
    }
  }

  pub mod user_dirs_public_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(32, 6, 169, 49, 222, 76, 142, 154),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 170, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 80, 117, 98, 108),
        ::capnp::word(105, 99, 68, 105, 114, 36, 80, 97),
        ::capnp::word(114, 97, 109, 115, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9a8e_4cde_31a9_0620;
    }
  }

  pub mod user_dirs_public_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(238, 241, 181, 245, 219, 127, 77, 167),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 178, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 80, 117, 98, 108),
        ::capnp::word(105, 99, 68, 105, 114, 36, 82, 101),
        ::capnp::word(115, 117, 108, 116, 115, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa74d_7fdb_f5b5_f1ee;
    }
  }

  pub mod user_dirs_template_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(188, 184, 118, 225, 57, 57, 224, 220),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 186, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 84, 101, 109, 112),
        ::capnp::word(108, 97, 116, 101, 68, 105, 114, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xdce0_3939_e176_b8bc;
    }
  }

  pub mod user_dirs_template_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(80, 103, 53, 246, 180, 221, 32, 156),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 194, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 84, 101, 109, 112),
        ::capnp::word(108, 97, 116, 101, 68, 105, 114, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9c20_ddb4_f635_6750;
    }
  }

  pub mod user_dirs_video_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 23] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(48, 73, 60, 196, 244, 99, 244, 250),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 162, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 86, 105, 100, 101),
        ::capnp::word(111, 68, 105, 114, 36, 80, 97, 114),
        ::capnp::word(97, 109, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xfaf4_63f4_c43c_4930;
    }
  }

  pub mod user_dirs_video_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 39] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(39, 106, 35, 201, 49, 129, 99, 216),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 170, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(53, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 117, 115, 101, 114),
        ::capnp::word(68, 105, 114, 115, 86, 105, 100, 101),
        ::capnp::word(111, 68, 105, 114, 36, 82, 101, 115),
        ::capnp::word(117, 108, 116, 115, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd863_8131_c923_6a27;
    }
  }

  pub mod temp_dir_new_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 22] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(29, 199, 229, 244, 238, 88, 5, 223),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 114, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 116, 101, 109, 112),
        ::capnp::word(68, 105, 114, 78, 101, 119, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xdf05_58ee_f4e5_c71d;
    }
  }

  pub mod temp_dir_new_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_temp_dir(self) -> ::capnp::Result<crate::cap_std_capnp::temp_dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_temp_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_temp_dir(self) -> ::capnp::Result<crate::cap_std_capnp::temp_dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_temp_dir(&mut self, value: crate::cap_std_capnp::temp_dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_temp_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_temp_dir(&self) -> crate::cap_std_capnp::temp_dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(23, 190, 189, 21, 238, 145, 30, 132),
        ::capnp::word(60, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 122, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 65, 109, 98, 105, 101),
        ::capnp::word(110, 116, 65, 117, 116, 104, 111, 114),
        ::capnp::word(105, 116, 121, 46, 116, 101, 109, 112),
        ::capnp::word(68, 105, 114, 78, 101, 119, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 66, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(116, 101, 109, 112, 68, 105, 114, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(46, 202, 23, 226, 67, 20, 54, 189),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::temp_dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x841e_91ee_15bd_be17;
    }
  }
}


pub mod project_dirs {
  #![allow(unused_variables)]
  pub type CacheDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::project_dirs::cache_dir_params::Owned>;
  pub type CacheDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::project_dirs::cache_dir_results::Owned>;
  pub type ConfigDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::project_dirs::config_dir_params::Owned>;
  pub type ConfigDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::project_dirs::config_dir_results::Owned>;
  pub type DataDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::project_dirs::data_dir_params::Owned>;
  pub type DataDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::project_dirs::data_dir_results::Owned>;
  pub type DataLocalDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::project_dirs::data_local_dir_params::Owned>;
  pub type DataLocalDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::project_dirs::data_local_dir_results::Owned>;
  pub type RuntimeDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::project_dirs::runtime_dir_params::Owned>;
  pub type RuntimeDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::project_dirs::runtime_dir_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn cache_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::project_dirs::cache_dir_params::Owned,crate::cap_std_capnp::project_dirs::cache_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn config_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::project_dirs::config_dir_params::Owned,crate::cap_std_capnp::project_dirs::config_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
    pub fn data_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::project_dirs::data_dir_params::Owned,crate::cap_std_capnp::project_dirs::data_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 2, ::core::option::Option::None)
    }
    pub fn data_local_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::project_dirs::data_local_dir_params::Owned,crate::cap_std_capnp::project_dirs::data_local_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 3, ::core::option::Option::None)
    }
    pub fn runtime_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::project_dirs::runtime_dir_params::Owned,crate::cap_std_capnp::project_dirs::runtime_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 4, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn cache_dir(&self, _: CacheDirParams<>, _: CacheDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method project_dirs::Server::cache_dir not implemented".to_string())) }
    async fn config_dir(&self, _: ConfigDirParams<>, _: ConfigDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method project_dirs::Server::config_dir not implemented".to_string())) }
    async fn data_dir(&self, _: DataDirParams<>, _: DataDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method project_dirs::Server::data_dir not implemented".to_string())) }
    async fn data_local_dir(&self, _: DataLocalDirParams<>, _: DataLocalDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method project_dirs::Server::data_local_dir not implemented".to_string())) }
    async fn runtime_dir(&self, _: RuntimeDirParams<>, _: RuntimeDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method project_dirs::Server::runtime_dir not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.cache_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.config_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          2 => server.data_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          3 => server.data_local_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          4 => server.runtime_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xb91a_bd9f_6c40_3bba;
    pub static ENCODED_NODE: [::capnp::Word; 76] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(186, 59, 64, 108, 159, 189, 26, 185),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 186, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 71, 1, 0, 0),
      ::capnp::word(1, 1, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
      ::capnp::word(99, 116, 68, 105, 114, 115, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(20, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(9, 1, 230, 201, 40, 48, 138, 168),
      ::capnp::word(205, 145, 179, 206, 36, 253, 169, 207),
      ::capnp::word(145, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(137, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(44, 21, 235, 173, 34, 51, 201, 244),
      ::capnp::word(181, 75, 62, 253, 6, 142, 51, 171),
      ::capnp::word(125, 0, 0, 0, 82, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(117, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(2, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(96, 9, 55, 121, 73, 206, 167, 189),
      ::capnp::word(190, 101, 20, 221, 117, 59, 26, 210),
      ::capnp::word(105, 0, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(93, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(3, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(78, 44, 158, 95, 132, 232, 36, 239),
      ::capnp::word(140, 214, 151, 38, 16, 232, 120, 163),
      ::capnp::word(81, 0, 0, 0, 106, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(73, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(4, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(125, 56, 190, 115, 32, 192, 55, 238),
      ::capnp::word(39, 114, 193, 62, 126, 144, 177, 195),
      ::capnp::word(61, 0, 0, 0, 90, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(53, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(99, 97, 99, 104, 101, 68, 105, 114),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(99, 111, 110, 102, 105, 103, 68, 105),
      ::capnp::word(114, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(100, 97, 116, 97, 68, 105, 114, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(100, 97, 116, 97, 76, 111, 99, 97),
      ::capnp::word(108, 68, 105, 114, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 117, 110, 116, 105, 109, 101, 68),
      ::capnp::word(105, 114, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod cache_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(9, 1, 230, 201, 40, 48, 138, 168),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 58, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 99),
        ::capnp::word(97, 99, 104, 101, 68, 105, 114, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa88a_3028_c9e6_0109;
    }
  }

  pub mod cache_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(205, 145, 179, 206, 36, 253, 169, 207),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 66, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 99),
        ::capnp::word(97, 99, 104, 101, 68, 105, 114, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xcfa9_fd24_ceb3_91cd;
    }
  }

  pub mod config_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(44, 21, 235, 173, 34, 51, 201, 244),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 66, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 99),
        ::capnp::word(111, 110, 102, 105, 103, 68, 105, 114),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf4c9_3322_adeb_152c;
    }
  }

  pub mod config_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(181, 75, 62, 253, 6, 142, 51, 171),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 74, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 99),
        ::capnp::word(111, 110, 102, 105, 103, 68, 105, 114),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xab33_8e06_fd3e_4bb5;
    }
  }

  pub mod data_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(96, 9, 55, 121, 73, 206, 167, 189),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 50, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 100),
        ::capnp::word(97, 116, 97, 68, 105, 114, 36, 80),
        ::capnp::word(97, 114, 97, 109, 115, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xbda7_ce49_7937_0960;
    }
  }

  pub mod data_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(190, 101, 20, 221, 117, 59, 26, 210),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 58, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 100),
        ::capnp::word(97, 116, 97, 68, 105, 114, 36, 82),
        ::capnp::word(101, 115, 117, 108, 116, 115, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xd21a_3b75_dd14_65be;
    }
  }

  pub mod data_local_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 22] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(78, 44, 158, 95, 132, 232, 36, 239),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 90, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 100),
        ::capnp::word(97, 116, 97, 76, 111, 99, 97, 108),
        ::capnp::word(68, 105, 114, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xef24_e884_5f9e_2c4e;
    }
  }

  pub mod data_local_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(140, 214, 151, 38, 16, 232, 120, 163),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 98, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 100),
        ::capnp::word(97, 116, 97, 76, 111, 99, 97, 108),
        ::capnp::word(68, 105, 114, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xa378_e810_2697_d68c;
    }
  }

  pub mod runtime_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 22] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(125, 56, 190, 115, 32, 192, 55, 238),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 74, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 114),
        ::capnp::word(117, 110, 116, 105, 109, 101, 68, 105),
        ::capnp::word(114, 36, 80, 97, 114, 97, 109, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xee37_c020_73be_387d;
    }
  }

  pub mod runtime_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 38] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(39, 114, 193, 62, 126, 144, 177, 195),
        ::capnp::word(55, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 82, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(49, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 80, 114, 111, 106, 101),
        ::capnp::word(99, 116, 68, 105, 114, 115, 46, 114),
        ::capnp::word(117, 110, 116, 105, 109, 101, 68, 105),
        ::capnp::word(114, 36, 82, 101, 115, 117, 108, 116),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xc3b1_907e_3ec1_7227;
    }
  }
}


pub mod user_dirs {
  #![allow(unused_variables)]
  pub type NewParams<> = ::capnp::capability::Params<crate::cap_std_capnp::user_dirs::new_params::Owned>;
  pub type NewResults<> = ::capnp::capability::Results<crate::cap_std_capnp::user_dirs::new_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn new_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::user_dirs::new_params::Owned,crate::cap_std_capnp::user_dirs::new_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn new(&self, _: NewParams<>, _: NewResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method user_dirs::Server::new not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.new(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0x8856_cc78_3191_c013;
    pub static ENCODED_NODE: [::capnp::Word; 32] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(19, 192, 145, 49, 120, 204, 86, 136),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 162, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 71, 0, 0, 0),
      ::capnp::word(81, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 85, 115, 101, 114, 68),
      ::capnp::word(105, 114, 115, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(4, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(6, 123, 238, 144, 21, 100, 16, 203),
      ::capnp::word(39, 130, 224, 142, 194, 176, 67, 147),
      ::capnp::word(17, 0, 0, 0, 34, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(5, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(110, 101, 119, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod new_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(6, 123, 238, 144, 21, 100, 16, 203),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 250, 1, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 85, 115, 101, 114, 68),
        ::capnp::word(105, 114, 115, 46, 110, 101, 119, 36),
        ::capnp::word(80, 97, 114, 97, 109, 115, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xcb10_6415_90ee_7b06;
    }
  }

  pub mod new_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_user_dirs(self) -> ::capnp::Result<crate::cap_std_capnp::user_dirs::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_user_dirs(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_user_dirs(self) -> ::capnp::Result<crate::cap_std_capnp::user_dirs::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_user_dirs(&mut self, value: crate::cap_std_capnp::user_dirs::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_user_dirs(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_user_dirs(&self) -> crate::cap_std_capnp::user_dirs::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(39, 130, 224, 142, 194, 176, 67, 147),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(41, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 85, 115, 101, 114, 68),
        ::capnp::word(105, 114, 115, 46, 110, 101, 119, 36),
        ::capnp::word(82, 101, 115, 117, 108, 116, 115, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 74, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(24, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(117, 115, 101, 114, 68, 105, 114, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(19, 192, 145, 49, 120, 204, 86, 136),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::user_dirs::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x9343_b0c2_8ee0_8227;
    }
  }
}


pub mod temp_dir {
  #![allow(unused_variables)]
  pub type CloseParams<> = ::capnp::capability::Params<crate::cap_std_capnp::temp_dir::close_params::Owned>;
  pub type CloseResults<> = ::capnp::capability::Results<crate::cap_std_capnp::temp_dir::close_results::Owned>;
  pub type GetAsDirParams<> = ::capnp::capability::Params<crate::cap_std_capnp::temp_dir::get_as_dir_params::Owned>;
  pub type GetAsDirResults<> = ::capnp::capability::Results<crate::cap_std_capnp::temp_dir::get_as_dir_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn close_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::temp_dir::close_params::Owned,crate::cap_std_capnp::temp_dir::close_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn get_as_dir_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::temp_dir::get_as_dir_params::Owned,crate::cap_std_capnp::temp_dir::get_as_dir_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn close(&self, _: CloseParams<>, _: CloseResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method temp_dir::Server::close not implemented".to_string())) }
    async fn get_as_dir(&self, _: GetAsDirParams<>, _: GetAsDirResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method temp_dir::Server::get_as_dir not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.close(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.get_as_dir(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xbd36_1443_e217_ca2e;
    pub static ENCODED_NODE: [::capnp::Word; 43] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(46, 202, 23, 226, 67, 20, 54, 189),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 154, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 135, 0, 0, 0),
      ::capnp::word(125, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 84, 101, 109, 112, 68),
      ::capnp::word(105, 114, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(8, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(82, 54, 224, 175, 252, 169, 137, 172),
      ::capnp::word(12, 39, 146, 126, 52, 103, 6, 236),
      ::capnp::word(49, 0, 0, 0, 50, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(87, 159, 154, 146, 81, 42, 16, 235),
      ::capnp::word(59, 182, 12, 133, 40, 158, 53, 243),
      ::capnp::word(25, 0, 0, 0, 74, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(17, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(99, 108, 111, 115, 101, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(103, 101, 116, 65, 115, 68, 105, 114),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod close_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 20] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(82, 54, 224, 175, 252, 169, 137, 172),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 2, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 84, 101, 109, 112, 68),
        ::capnp::word(105, 114, 46, 99, 108, 111, 115, 101),
        ::capnp::word(36, 80, 97, 114, 97, 109, 115, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xac89_a9fc_afe0_3652;
    }
  }

  pub mod close_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(12, 39, 146, 126, 52, 103, 6, 236),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 10, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 84, 101, 109, 112, 68),
        ::capnp::word(105, 114, 46, 99, 108, 111, 115, 101),
        ::capnp::word(36, 82, 101, 115, 117, 108, 116, 115),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xec06_6734_7e92_270c;
    }
  }

  pub mod get_as_dir_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(87, 159, 154, 146, 81, 42, 16, 235),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 84, 101, 109, 112, 68),
        ::capnp::word(105, 114, 46, 103, 101, 116, 65, 115),
        ::capnp::word(68, 105, 114, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xeb10_2a51_929a_9f57;
    }
  }

  pub mod get_as_dir_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dir(self) -> ::capnp::Result<crate::cap_std_capnp::dir::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_dir(&mut self, value: crate::cap_std_capnp::dir::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_dir(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_dir(&self) -> crate::cap_std_capnp::dir::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(59, 182, 12, 133, 40, 158, 53, 243),
        ::capnp::word(51, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 84, 101, 109, 112, 68),
        ::capnp::word(105, 114, 46, 103, 101, 116, 65, 115),
        ::capnp::word(68, 105, 114, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 34, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 105, 114, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 33, 185, 185, 102, 125, 116, 162),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::dir::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf335_9e28_850c_b63b;
    }
  }
}


pub mod temp_file {
  #![allow(unused_variables)]
  pub type AsFileParams<> = ::capnp::capability::Params<crate::cap_std_capnp::temp_file::as_file_params::Owned>;
  pub type AsFileResults<> = ::capnp::capability::Results<crate::cap_std_capnp::temp_file::as_file_results::Owned>;
  pub type ReplaceParams<> = ::capnp::capability::Params<crate::cap_std_capnp::temp_file::replace_params::Owned>;
  pub type ReplaceResults<> = ::capnp::capability::Results<crate::cap_std_capnp::temp_file::replace_results::Owned>;

  pub struct Client {
    pub client: ::capnp::capability::Client,
  }
  impl  ::capnp::capability::FromClientHook for Client {
    fn new(hook: Box<dyn (::capnp::private::capability::ClientHook)>) -> Self {
      Self { client: ::capnp::capability::Client::new(hook),  }
    }
    fn into_client_hook(self) -> Box<dyn (::capnp::private::capability::ClientHook)> {
      self.client.hook
    }
    fn as_client_hook(&self) -> &dyn (::capnp::private::capability::ClientHook) {
      &*self.client.hook
    }
  }
  impl  ::capnp::introspect::Introspect for Client { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  #[derive(Copy, Clone)]
  pub struct Owned(());
  impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Capability(::capnp::introspect::RawCapabilitySchema { encoded_node: &_private::ENCODED_NODE }).into() } }
  impl ::capnp::traits::Owned for Owned { type Reader<'a> = Client; type Builder<'a> = Client; }
  impl ::capnp::traits::Pipelined for Owned { type Pipeline = Client; }
  impl <'a,> ::capnp::traits::FromPointerReader<'a> for Client<>  {
    fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(reader.get_capability()?))
    }
  }
  impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Client<>  {
    fn init_pointer(_builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
      unimplemented!()
    }
    fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
      ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(builder.get_capability()?))
    }
  }

  impl <> ::capnp::traits::SetPointerBuilder for Client<>  {
    fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, from: Self, _canonicalize: bool) -> ::capnp::Result<()> {
      pointer.set_capability(from.client.hook);
      ::core::result::Result::Ok(())
    }
  }
  impl  ::capnp::traits::HasTypeId for Client {
    const TYPE_ID: u64 = _private::TYPE_ID;
  }
  impl  Clone for Client {
    fn clone(&self) -> Self {
      Self { client: ::capnp::capability::Client::new(self.client.hook.add_ref()),  }
    }
  }
  impl  Client {
    pub fn as_file_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::temp_file::as_file_params::Owned,crate::cap_std_capnp::temp_file::as_file_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 0, ::core::option::Option::None)
    }
    pub fn replace_request(&self) -> ::capnp::capability::Request<crate::cap_std_capnp::temp_file::replace_params::Owned,crate::cap_std_capnp::temp_file::replace_results::Owned> {
      self.client.new_call(_private::TYPE_ID, 1, ::core::option::Option::None)
    }
  }
  #[allow(async_fn_in_trait)]
  pub trait Server<>   {
    async fn as_file(&self, _: AsFileParams<>, _: AsFileResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method temp_file::Server::as_file not implemented".to_string())) }
    async fn replace(&self, _: ReplaceParams<>, _: ReplaceResults<>) -> Result<(), ::capnp::Error> { Result::<(), capnp::Error>::Err(::capnp::Error::unimplemented("method temp_file::Server::replace not implemented".to_string())) }
  }
  pub struct ServerDispatch<_T,> {
    pub server: _T,
  }
  impl <_S: Server + 'static, > ::capnp::capability::FromServer<_S> for Client   {
    type Dispatch = ServerDispatch<_S, >;
    fn from_server(s: _S) -> ServerDispatch<_S, > {
      ServerDispatch { server: s,  }
    }
  }
  impl <_T: Server> ::core::ops::Deref for ServerDispatch<_T> {
    type Target = _T;
    fn deref(&self) -> &_T { &self.server}
  }
  impl <_T: Server> ::core::ops::DerefMut for ServerDispatch<_T> {
    fn deref_mut(&mut self) -> &mut _T { &mut self.server}
  }
  impl <_T: Server> ::capnp::capability::Server for ServerDispatch<_T> {
    async fn dispatch_call(&self, interface_id: u64, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
      match interface_id {
        _private::TYPE_ID => Self::dispatch_call_internal(&self.server, method_id, params, results).await,
        _ =>  Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  impl <_T :Server> ServerDispatch<_T> {
    pub async fn dispatch_call_internal(server: &_T, method_id: u16, params: ::capnp::capability::Params<::capnp::any_pointer::Owned>, results: ::capnp::capability::Results<::capnp::any_pointer::Owned>) -> Result<(), ::capnp::Error> {
        match method_id {
          0 => server.as_file(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          1 => server.replace(::capnp::private::capability::internal_get_typed_params(params), ::capnp::private::capability::internal_get_typed_results(results)).await,
          _ => Err(::capnp::Error::unimplemented("Method not implemented.".to_string())) 
      }
    }
  }
  pub mod _private {
    pub const TYPE_ID: u64 = 0xc8a2_f2f4_2add_b7b6;
    pub static ENCODED_NODE: [::capnp::Word; 42] = [
      ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
      ::capnp::word(182, 183, 221, 42, 244, 242, 162, 200),
      ::capnp::word(43, 0, 0, 0, 3, 0, 0, 0),
      ::capnp::word(63, 134, 108, 37, 212, 58, 183, 213),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(21, 0, 0, 0, 162, 1, 0, 0),
      ::capnp::word(45, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(41, 0, 0, 0, 135, 0, 0, 0),
      ::capnp::word(121, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
      ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
      ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
      ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
      ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
      ::capnp::word(110, 112, 58, 84, 101, 109, 112, 70),
      ::capnp::word(105, 108, 101, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
      ::capnp::word(8, 0, 0, 0, 3, 0, 5, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(33, 113, 90, 154, 66, 240, 219, 177),
      ::capnp::word(180, 27, 33, 119, 209, 176, 206, 238),
      ::capnp::word(49, 0, 0, 0, 58, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(37, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(1, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(61, 220, 103, 189, 230, 1, 120, 242),
      ::capnp::word(199, 211, 196, 15, 153, 231, 13, 153),
      ::capnp::word(25, 0, 0, 0, 66, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ::capnp::word(13, 0, 0, 0, 7, 0, 0, 0),
      ::capnp::word(97, 115, 70, 105, 108, 101, 0, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(114, 101, 112, 108, 97, 99, 101, 0),
      ::capnp::word(0, 0, 0, 0, 0, 0, 1, 0),
      ::capnp::word(0, 0, 0, 0, 1, 0, 1, 0),
    ];
  }

  pub mod as_file_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(33, 113, 90, 154, 66, 240, 219, 177),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 18, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 84, 101, 109, 112, 70),
        ::capnp::word(105, 108, 101, 46, 97, 115, 70, 105),
        ::capnp::word(108, 101, 36, 80, 97, 114, 97, 109),
        ::capnp::word(115, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xb1db_f042_9a5a_7121;
    }
  }

  pub mod as_file_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.reader.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_file(self) -> ::capnp::Result<crate::cap_std_capnp::file::Client> {
        match self.builder.get_pointer_field(0).get_capability() { ::core::result::Result::Ok(c) => ::core::result::Result::Ok(::capnp::capability::FromClientHook::new(c)), ::core::result::Result::Err(e) => ::core::result::Result::Err(e)}
      }
      #[inline]
      pub fn set_file(&mut self, value: crate::cap_std_capnp::file::Client)  {
        self.builder.reborrow().get_pointer_field(0).set_capability(value.client.hook);
      }
      #[inline]
      pub fn has_file(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
      pub fn get_file(&self) -> crate::cap_std_capnp::file::Client {
        ::capnp::capability::FromClientHook::new(self._typeless.get_pointer_field(0).as_cap())
      }
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(180, 27, 33, 119, 209, 176, 206, 238),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 84, 101, 109, 112, 70),
        ::capnp::word(105, 108, 101, 46, 97, 115, 70, 105),
        ::capnp::word(108, 101, 36, 82, 101, 115, 117, 108),
        ::capnp::word(116, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(102, 105, 108, 101, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(194, 85, 54, 62, 107, 185, 154, 255),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(17, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <crate::cap_std_capnp::file::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xeece_b0d1_7721_1bb4;
    }
  }

  pub mod replace_params {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
      #[inline]
      pub fn get_dest(self) -> ::capnp::Result<::capnp::text::Reader<'a>> {
        ::capnp::traits::FromPointerReader::get_from_pointer(&self.reader.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn has_dest(&self) -> bool {
        !self.reader.get_pointer_field(0).is_null()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 1 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
      #[inline]
      pub fn get_dest(self) -> ::capnp::Result<::capnp::text::Builder<'a>> {
        ::capnp::traits::FromPointerBuilder::get_from_pointer(self.builder.get_pointer_field(0), ::core::option::Option::None)
      }
      #[inline]
      pub fn set_dest(&mut self, value: ::capnp::text::Reader<'_>)  {
        self.builder.reborrow().get_pointer_field(0).set_text(value);
      }
      #[inline]
      pub fn init_dest(self, size: u32) -> ::capnp::text::Builder<'a> {
        self.builder.get_pointer_field(0).init_text(size)
      }
      #[inline]
      pub fn has_dest(&self) -> bool {
        !self.builder.is_pointer_field_null(0)
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 37] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(61, 220, 103, 189, 230, 1, 120, 242),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(1, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 26, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(45, 0, 0, 0, 63, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 84, 101, 109, 112, 70),
        ::capnp::word(105, 108, 101, 46, 114, 101, 112, 108),
        ::capnp::word(97, 99, 101, 36, 80, 97, 114, 97),
        ::capnp::word(109, 115, 0, 0, 0, 0, 0, 0),
        ::capnp::word(4, 0, 0, 0, 3, 0, 4, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 1, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(13, 0, 0, 0, 42, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(8, 0, 0, 0, 3, 0, 1, 0),
        ::capnp::word(20, 0, 0, 0, 2, 0, 1, 0),
        ::capnp::word(100, 101, 115, 116, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(12, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        match index {
          0 => <::capnp::text::Owned as ::capnp::introspect::Introspect>::introspect(),
          _ => panic!("invalid field index {}", index),
        }
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[0];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0xf278_01e6_bd67_dc3d;
    }
  }

  pub mod replace_results {
    #[derive(Copy, Clone)]
    pub struct Owned(());
    impl ::capnp::introspect::Introspect for Owned { fn introspect() -> ::capnp::introspect::Type { ::capnp::introspect::TypeVariant::Struct(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types, annotation_types: _private::get_annotation_types }).into() } }
    impl ::capnp::traits::Owned for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::OwnedStruct for Owned { type Reader<'a> = Reader<'a>; type Builder<'a> = Builder<'a>; }
    impl ::capnp::traits::Pipelined for Owned { type Pipeline = Pipeline; }

    pub struct Reader<'a> { reader: ::capnp::private::layout::StructReader<'a> }
    impl <'a,> ::core::marker::Copy for Reader<'a,>  {}
    impl <'a,> ::core::clone::Clone for Reader<'a,>  {
      fn clone(&self) -> Self { *self }
    }

    impl <'a,> ::capnp::traits::HasTypeId for Reader<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructReader<'a>> for Reader<'a,>  {
      fn from(reader: ::capnp::private::layout::StructReader<'a>) -> Self {
        Self { reader,  }
      }
    }

    impl <'a,> ::core::convert::From<Reader<'a,>> for ::capnp::dynamic_value::Reader<'a>  {
      fn from(reader: Reader<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Reader::new(reader.reader, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::core::fmt::Debug for Reader<'a,>  {
      fn fmt(&self, f: &mut ::core::fmt::Formatter<'_>) -> ::core::result::Result<(), ::core::fmt::Error> {
        core::fmt::Debug::fmt(&::core::convert::Into::<::capnp::dynamic_value::Reader<'_>>::into(*self), f)
      }
    }

    impl <'a,> ::capnp::traits::FromPointerReader<'a> for Reader<'a,>  {
      fn get_from_pointer(reader: &::capnp::private::layout::PointerReader<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(reader.get_struct(default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::IntoInternalStructReader<'a> for Reader<'a,>  {
      fn into_internal_struct_reader(self) -> ::capnp::private::layout::StructReader<'a> {
        self.reader
      }
    }

    impl <'a,> ::capnp::traits::Imbue<'a> for Reader<'a,>  {
      fn imbue(&mut self, cap_table: &'a ::capnp::private::layout::CapTable) {
        self.reader.imbue(::capnp::private::layout::CapTableReader::Plain(cap_table))
      }
    }

    impl <'a,> Reader<'a,>  {
      pub fn reborrow(&self) -> Reader<'_,> {
        Self { .. *self }
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.reader.total_size()
      }
    }

    pub struct Builder<'a> { builder: ::capnp::private::layout::StructBuilder<'a> }
    impl <'a,> ::capnp::traits::HasStructSize for Builder<'a,>  {
      const STRUCT_SIZE: ::capnp::private::layout::StructSize = ::capnp::private::layout::StructSize { data: 0, pointers: 0 };
    }
    impl <'a,> ::capnp::traits::HasTypeId for Builder<'a,>  {
      const TYPE_ID: u64 = _private::TYPE_ID;
    }
    impl <'a,> ::core::convert::From<::capnp::private::layout::StructBuilder<'a>> for Builder<'a,>  {
      fn from(builder: ::capnp::private::layout::StructBuilder<'a>) -> Self {
        Self { builder,  }
      }
    }

    impl <'a,> ::core::convert::From<Builder<'a,>> for ::capnp::dynamic_value::Builder<'a>  {
      fn from(builder: Builder<'a,>) -> Self {
        Self::Struct(::capnp::dynamic_struct::Builder::new(builder.builder, ::capnp::schema::StructSchema::new(::capnp::introspect::RawBrandedStructSchema { generic: &_private::RAW_SCHEMA, field_types: _private::get_field_types::<>, annotation_types: _private::get_annotation_types::<>})))
      }
    }

    impl <'a,> ::capnp::traits::ImbueMut<'a> for Builder<'a,>  {
      fn imbue_mut(&mut self, cap_table: &'a mut ::capnp::private::layout::CapTable) {
        self.builder.imbue(::capnp::private::layout::CapTableBuilder::Plain(cap_table))
      }
    }

    impl <'a,> ::capnp::traits::FromPointerBuilder<'a> for Builder<'a,>  {
      fn init_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, _size: u32) -> Self {
        builder.init_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE).into()
      }
      fn get_from_pointer(builder: ::capnp::private::layout::PointerBuilder<'a>, default: ::core::option::Option<&'a [::capnp::Word]>) -> ::capnp::Result<Self> {
        ::core::result::Result::Ok(builder.get_struct(<Self as ::capnp::traits::HasStructSize>::STRUCT_SIZE, default)?.into())
      }
    }

    impl <'a,> ::capnp::traits::SetPointerBuilder for Reader<'a,>  {
      fn set_pointer_builder(mut pointer: ::capnp::private::layout::PointerBuilder<'_>, value: Self, canonicalize: bool) -> ::capnp::Result<()> { pointer.set_struct(&value.reader, canonicalize) }
    }

    impl <'a,> Builder<'a,>  {
      pub fn into_reader(self) -> Reader<'a,> {
        self.builder.into_reader().into()
      }
      pub fn reborrow(&mut self) -> Builder<'_,> {
        Builder { builder: self.builder.reborrow() }
      }
      pub fn reborrow_as_reader(&self) -> Reader<'_,> {
        self.builder.as_reader().into()
      }

      pub fn total_size(&self) -> ::capnp::Result<::capnp::MessageSize> {
        self.builder.as_reader().total_size()
      }
    }

    pub struct Pipeline { _typeless: ::capnp::any_pointer::Pipeline }
    impl ::capnp::capability::FromTypelessPipeline for Pipeline {
      fn new(typeless: ::capnp::any_pointer::Pipeline) -> Self {
        Self { _typeless: typeless,  }
      }
    }
    impl Pipeline  {
    }
    mod _private {
      pub static ENCODED_NODE: [::capnp::Word; 21] = [
        ::capnp::word(0, 0, 0, 0, 5, 0, 6, 0),
        ::capnp::word(199, 211, 196, 15, 153, 231, 13, 153),
        ::capnp::word(52, 0, 0, 0, 1, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 7, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(21, 0, 0, 0, 34, 2, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(0, 0, 0, 0, 0, 0, 0, 0),
        ::capnp::word(70, 58, 47, 99, 111, 100, 101, 47),
        ::capnp::word(107, 101, 121, 115, 116, 111, 110, 101),
        ::capnp::word(47, 99, 111, 114, 101, 47, 115, 99),
        ::capnp::word(104, 101, 109, 97, 47, 99, 97, 112),
        ::capnp::word(95, 115, 116, 100, 46, 99, 97, 112),
        ::capnp::word(110, 112, 58, 84, 101, 109, 112, 70),
        ::capnp::word(105, 108, 101, 46, 114, 101, 112, 108),
        ::capnp::word(97, 99, 101, 36, 82, 101, 115, 117),
        ::capnp::word(108, 116, 115, 0, 0, 0, 0, 0),
      ];
      pub fn get_field_types(index: u16) -> ::capnp::introspect::Type {
        panic!("invalid field index {}", index)
      }
      pub fn get_annotation_types(child_index: Option<u16>, index: u32) -> ::capnp::introspect::Type {
        panic!("invalid annotation indices ({:?}, {}) ", child_index, index)
      }
      pub static RAW_SCHEMA: ::capnp::introspect::RawStructSchema = ::capnp::introspect::RawStructSchema {
        encoded_node: &ENCODED_NODE,
        nonunion_members: NONUNION_MEMBERS,
        members_by_discriminant: MEMBERS_BY_DISCRIMINANT,
      };
      pub static NONUNION_MEMBERS : &[u16] = &[];
      pub static MEMBERS_BY_DISCRIMINANT : &[u16] = &[];
      pub const TYPE_ID: u64 = 0x990d_e799_0fc4_d3c7;
    }
  }
}
