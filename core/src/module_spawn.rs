// cargo test -- --nocapture -- --exact "module_spawn"
// success looks like "remote stderr: reply sent and acquired: Hello, test!"
// then ctrl-c
pub mod module_spawn_process {
    /*
    use capnp::capability::Promise;
    use capnp_rpc::pry;
    use crate::unix_process_capnp::{
        unix_process_api::Owned as UnixProcessApi,
        unix_process_args::Owned as UnixProcessArgs,
        unix_process_error::Owned as UnixProcessError,
    };
    use crate::modulespawn_capnp::{module_spawn, module_spawn::Client, wrap_process_spawn};
    use crate::modulespawn_capnp::{
        sealed_reference::Owned as SealedReference,
    };
    use crate::modulespawn_capnp;
    pub struct ModuleSpawnImpl();
    pub struct WrapProcessSpawnImpl();
    */
    /*
     *
    interface ModuleSpawn(SealedReference, Module, ModuleError) {
        spawn @0 (reference: SealedReference) -> (result :Process(Module, ModuleError));
    }
     */
    /*
    // ideally we'd pull UnixProcessApi and UnixProcessError out of UnixProcessServiceSpawnImpl(), but I don't know how
    type SpawnParams = module_spawn::SpawnParams<SealedReference, UnixProcessApi, UnixProcessError>;
    type SpawnResults = module_spawn::SpawnResults<SealedReference, UnixProcessApi, UnixProcessError>;

    impl module_spawn::Server<SealedReference, UnixProcessApi, UnixProcessError> for ModuleSpawnImpl {
        fn spawn(&mut self, params: SpawnParams, mut results: SpawnResults) -> Promise<(), capnp::Error> {
            let params_reader = pry!(params.get());
            let reference = pry!(params_reader.get_reference());
            //Ok(())

            Promise::ok(())
            /*
            match UnixProcessImpl::spawn_process(program, argv.into_iter(), stdout, stderr) {
                Err(e) => Promise::err(capnp::Error::failed(e.to_string())),
                Ok(process_impl) => {
                    let server_pointer = Rc::new(RefCell::new(process_impl));
                    let process_client: UnixProcessClient = capnp_rpc::new_client(server_pointer);
                    results.get().set_result(process_client);
                    Promise::ok(())
                }
            }
            */
        }
    }
    */
    #[cfg(test)]
    mod tests {
        // Warning: lots of code here was generated by GPT-4 and modified until it works so it's
        // probably somewhat insane, tread carefully. And rip out whatever sucks.
        use tokio::sync::mpsc;
        use tokio::time::{sleep, Duration};
        use tokio::task;
        use tokio::io::{AsyncRead, ReadBuf,AsyncWrite, AsyncWriteExt};

        use capnp::capability::Promise;
        use capnp_rpc::{rpc_twoparty_capnp, twoparty, RpcSystem};
        use crate::hello_world_capnp::hello_world;
        use crate::byte_stream::ByteStreamImpl;
        use crate::spawn::unix_process::{UnixProcessServiceSpawnImpl, UnixProcessServiceSpawnClient};
        use capnp_rpc::pry;

        use std::sync::{Arc, Mutex};
        use std::pin::Pin;
        use std::task::{Context, Poll};
        use std::io::Error;

        struct ReadWrapper {
            buffer: Arc<Mutex<Vec<u8>>>, // A shared buffer to hold incoming bytes.
        }
        impl AsyncRead for ReadWrapper {
            fn poll_read(
                mut self: Pin<&mut Self>,
                cx: &mut Context<'_>,
                buf: &mut ReadBuf<'_>,
            ) -> Poll<std::io::Result<()>> {
                let mut guard = self.buffer.lock().unwrap();
                if guard.is_empty() {
                    drop(guard);
                    cx.waker().wake_by_ref(); // Notify the executor to poll again later.
                    // Right now we're polling constantly, but it seems like a good idea to only poll when there is new data.
                    // I am unsure if that is a worthwhile optimization though.
                    Poll::Pending

                } else {
                    // If we have data in our buffer, we provide it to the ReadBuf.
                    let len = std::cmp::min(buf.remaining(), guard.len());
                    buf.put_slice(&guard[..len]);
                    guard.drain(..len);
                    Poll::Ready(Ok(()))
                }
            }
        }


        use crate::byte_stream_capnp::byte_stream::Client as ByteStreamClient;
        struct WriteWrapper {
            write_sender: mpsc::Sender<Vec<u8>>,
        }

        impl AsyncWrite for WriteWrapper {
            fn poll_write(
                mut self: Pin<&mut Self>,
                cx: &mut Context<'_>,
                buf: &[u8],
            ) -> Poll<std::io::Result<usize>> {
                let data = buf.to_vec();
                // Necessary because 'AsyncWrite' is actually synchronous and uses polling
                // If it were async we could just call stdin_server.write_bytes(&data).await;
                // But it isn't so we can't and have to use something like mpsc
                // to later write the data from an async context
                match self.write_sender.try_send(data) {
                    Ok(()) => Poll::Ready(Ok(buf.len())),
                    Err(e) => match e {
                        mpsc::error::TrySendError::Full(data) => {
                            cx.waker().wake_by_ref();
                            Poll::Pending
                        },
                        mpsc::error::TrySendError::Closed(data) => {
                            Poll::Ready(Err(std::io::Error::new(std::io::ErrorKind::WriteZero, "channel closed")))
                        },
                    },
                }
            }
            // unsure what these need, if anything.
            fn poll_flush(
                self: Pin<&mut Self>,
                _cx: &mut Context<'_>,
            ) -> Poll<Result<(), Error>> {
                Poll::Ready(Ok(()))
            }
            fn poll_shutdown(
                self: Pin<&mut Self>,
                _cx: &mut Context<'_>,
            ) -> Poll<Result<(), Error>> {
                Poll::Ready(Ok(()))
            }
        }
        pub struct HelloWorldImpl;

        impl hello_world::Server for HelloWorldImpl {
            fn say_hello(
                &mut self,
                params: hello_world::SayHelloParams,
                mut results: hello_world::SayHelloResults,
            ) -> Promise<(), ::capnp::Error> {
                println!("HelloWorldImpl say_hello was called!");

                let request = pry!(pry!(params.get()).get_request());
                let name = pry!(request.get_name());
                let message = format!("Hello, {name}!");
                println!("HelloWorldImpl got {}", name);
                results.get().init_reply().set_message(message[..].into());

                Promise::ok(())
            }
        }
        #[tokio::test]
        // The most basic example: how to talk over ServiceSpawn's bytestreams.
        async fn test_module_creation() {
            let spawn_process_server = UnixProcessServiceSpawnImpl();
            let spawn_process_client: UnixProcessServiceSpawnClient = capnp_rpc::new_client(spawn_process_server);

            let e = task::LocalSet::new().run_until(async {
                println!("modulespawn start");
                let mut read_wrapper = ReadWrapper {
                    buffer: Arc::new(Mutex::new(Vec::new())),
                };

                let buffer = read_wrapper.buffer.clone();
                let stdout_server = ByteStreamImpl::new(move |bytes| {
                    let mut guard = buffer.lock().unwrap();
                    guard.extend_from_slice(bytes);
                    match std::str::from_utf8(bytes) {
                        Ok(value) => {
                            println!("remote stdout: {}", value);
                        },
                        Err(e) => {
                            println!("remote stdout got utf8 unprintable bytes and thus an error: {:?}", e);
                        }
                    }
                    Promise::ok(())
                });
                let stdout_client = capnp_rpc::new_client(stdout_server);
                let stderr_server = ByteStreamImpl::new(|bytes| {
                    println!("remote stderr: {}", std::str::from_utf8(bytes).unwrap());
                    Promise::ok(())
                });
                let stderr_client = capnp_rpc::new_client(stderr_server);
                use std::env;

                let process_client = spawn_process_client.request_spawn_process(
                    "../target/debug/keystone-hello-world-module",
                    &["client", "test"],
                    stdout_client,
                    stderr_client).await?;

                let (write_sender, mut write_receiver) = mpsc::channel::<Vec<u8>>(32);
                let mut write_wrapper = WriteWrapper {
                    write_sender: write_sender,
                };
                let hello_world_client: hello_world::Client = capnp_rpc::new_client(HelloWorldImpl);

                let reader = tokio_util::compat::TokioAsyncReadCompatExt::compat(read_wrapper);
                let writer = tokio_util::compat::TokioAsyncWriteCompatExt::compat_write(write_wrapper);
                let network = twoparty::VatNetwork::new(
                    reader,
                    writer,
                    rpc_twoparty_capnp::Side::Server,
                    Default::default(),
                );
                let rpc_system = RpcSystem::new(Box::new(network), Some(hello_world_client.clone().client));

                tokio::task::spawn_local(rpc_system);
                println!("spawned rpc");

                let api_response = process_client.getapi_request().send().promise.await?;
                let api_reader = api_response.get()?.get_api()?;
                let stdin_server = api_reader.get_stdin()?;

                println!("looping");
                while let Some(data) = write_receiver.recv().await {
                    let _ = stdin_server.write_bytes(&data).await;
                }
                println!("should never reach this");

                let geterror_response = process_client.geterror_request().send().promise.await?;
                let error_reader = geterror_response.get()?.get_result()?;

                let error_code = error_reader.get_error_code();
                assert_eq!(error_code, 0);

                let error_message = error_reader.get_error_message()?;
                assert!(error_message.is_empty() == true);

                Ok::<(), eyre::Error>(())
            }).await;

            println!("inside modulespawn");
            e.unwrap();
        }
    }
}
