// cargo test -- --nocapture -- --exact "module_spawn"
// success looks like "remote stderr: reply sent and acquired: Hello, test!"
// then ctrl-c
pub mod module_spawn_process {
    #[cfg(test)]
    mod tests {
        // Warning: lots of code here was generated by GPT-4 and modified until it works so it's
        // probably somewhat insane, tread carefully. And rip out whatever sucks.
        use tokio::sync::mpsc;
        use tokio::time::{sleep, Duration};
        use tokio::task;
        use tokio::io::{AsyncRead, ReadBuf,AsyncWrite, AsyncWriteExt};

        use capnp::capability::Promise;
        use capnp_rpc::{rpc_twoparty_capnp, twoparty, RpcSystem};
        use crate::hello_world_capnp::hello_world;
        use crate::byte_stream::ByteStreamImpl;
        use crate::spawn::unix_process::{UnixProcessServiceSpawnImpl, UnixProcessServiceSpawnClient};
        use capnp_rpc::pry;

        use std::sync::{Arc, Mutex};
        use std::pin::Pin;
        use std::task::{Context, Poll};
        use std::io::Error;
        use tokio::process::Command;


        struct ReadWrapper {
            buffer: Arc<Mutex<Vec<u8>>>, // A shared buffer to hold incoming bytes.
        }
        impl AsyncRead for ReadWrapper {
            fn poll_read(
                mut self: Pin<&mut Self>,
                cx: &mut Context<'_>,
                buf: &mut ReadBuf<'_>,
            ) -> Poll<std::io::Result<()>> {
                let mut guard = self.buffer.lock().unwrap();
                if guard.is_empty() {
                    drop(guard);
                    cx.waker().wake_by_ref(); // Notify the executor to poll again later.
                    // Right now we're polling constantly, but it seems like a good idea to only poll when there is new data.
                    // I am unsure if that is a worthwhile optimization though.
                    Poll::Pending

                } else {
                    // If we have data in our buffer, we provide it to the ReadBuf.
                    let len = std::cmp::min(buf.remaining(), guard.len());
                    buf.put_slice(&guard[..len]);
                    guard.drain(..len);
                    Poll::Ready(Ok(()))
                }
            }
        }


        use crate::byte_stream_capnp::byte_stream::Client as ByteStreamClient;
        struct WriteWrapper {
            write_sender: mpsc::Sender<Vec<u8>>,
        }

        impl AsyncWrite for WriteWrapper {
            fn poll_write(
                mut self: Pin<&mut Self>,
                cx: &mut Context<'_>,
                buf: &[u8],
            ) -> Poll<std::io::Result<usize>> {
                let data = buf.to_vec();
                // Necessary because 'AsyncWrite' is actually synchronous and uses polling
                // If it were async we could just call stdin_server.write_bytes(&data).await;
                // But it isn't so we can't and have to use something like mpsc
                // to later write the data from an async context
                match self.write_sender.try_send(data) {
                    Ok(()) => Poll::Ready(Ok(buf.len())),
                    Err(e) => match e {
                        mpsc::error::TrySendError::Full(data) => {
                            cx.waker().wake_by_ref();
                            Poll::Pending
                        },
                        mpsc::error::TrySendError::Closed(data) => {
                            Poll::Ready(Err(std::io::Error::new(std::io::ErrorKind::WriteZero, "channel closed")))
                        },
                    },
                }
            }
            // unsure what these need, if anything.
            fn poll_flush(
                self: Pin<&mut Self>,
                _cx: &mut Context<'_>,
            ) -> Poll<Result<(), Error>> {
                Poll::Ready(Ok(()))
            }
            fn poll_shutdown(
                self: Pin<&mut Self>,
                _cx: &mut Context<'_>,
            ) -> Poll<Result<(), Error>> {
                Poll::Ready(Ok(()))
            }
        }
        pub struct HelloWorldImpl;

        impl hello_world::Server for HelloWorldImpl {
            fn say_hello(
                &mut self,
                params: hello_world::SayHelloParams,
                mut results: hello_world::SayHelloResults,
            ) -> Promise<(), ::capnp::Error> {
                println!("HelloWorldImpl say_hello was called!");

                let request = pry!(pry!(params.get()).get_request());
                let name = pry!(request.get_name());
                let message = format!("Hello, {name}!");
                println!("HelloWorldImpl got {}", name);
                results.get().init_reply().set_message(message[..].into());

                Promise::ok(())
            }
        }

        // This one works:
        #[tokio::test]
        // Talking over ServiceSpawn's bytestreams as the server while spawning a client module
        async fn test_module_creation_server_with_bytestreams() {
            let spawn_process_server = UnixProcessServiceSpawnImpl();
            let spawn_process_client: UnixProcessServiceSpawnClient = capnp_rpc::new_client(spawn_process_server);

            let e = task::LocalSet::new().run_until(async {
                println!("modulespawn start");
                let mut read_wrapper = ReadWrapper {
                    buffer: Arc::new(Mutex::new(Vec::new())),
                };

                let buffer = read_wrapper.buffer.clone();
                let stdout_server = ByteStreamImpl::new(move |bytes| {
                    let mut guard = buffer.lock().unwrap();
                    guard.extend_from_slice(bytes);
                    match std::str::from_utf8(bytes) {
                        Ok(value) => {
                            println!("remote stdout: {}", value);
                        },
                        Err(e) => {
                            println!("remote stdout got utf8 unprintable bytes and thus an error: {:?}", e);
                        }
                    }
                    Promise::ok(())
                });
                let stdout_client = capnp_rpc::new_client(stdout_server);
                let stderr_server = ByteStreamImpl::new(|bytes| {
                    println!("remote stderr: {}", std::str::from_utf8(bytes).unwrap());
                    Promise::ok(())
                });
                let stderr_client = capnp_rpc::new_client(stderr_server);

                let process_client = spawn_process_client.request_spawn_process(
                    "../target/debug/keystone-hello-world-module",
                    &["client", "test"],
                    stdout_client,
                    stderr_client).await?;

                let (write_sender, mut write_receiver) = mpsc::channel::<Vec<u8>>(32);
                let mut write_wrapper = WriteWrapper {
                    write_sender: write_sender,
                };
                let hello_world_client: hello_world::Client = capnp_rpc::new_client(HelloWorldImpl);

                let reader = tokio_util::compat::TokioAsyncReadCompatExt::compat(read_wrapper);
                let writer = tokio_util::compat::TokioAsyncWriteCompatExt::compat_write(write_wrapper);
                let network = twoparty::VatNetwork::new(
                    reader,
                    writer,
                    rpc_twoparty_capnp::Side::Server,
                    Default::default(),
                );
                let rpc_system = RpcSystem::new(Box::new(network), Some(hello_world_client.clone().client));

                tokio::task::spawn_local(rpc_system);
                println!("spawned rpc");

                let api_response = process_client.getapi_request().send().promise.await?;
                let api_reader = api_response.get()?.get_api()?;
                let stdin_server = api_reader.get_stdin()?;

                println!("looping");
                while let Some(data) = write_receiver.recv().await {
                    let _ = stdin_server.write_bytes(&data).await;
                }
                println!("should never reach this");

                let geterror_response = process_client.geterror_request().send().promise.await?;
                let error_reader = geterror_response.get()?.get_result()?;

                let error_code = error_reader.get_error_code();
                assert_eq!(error_code, 0);

                let error_message = error_reader.get_error_message()?;
                assert!(error_message.is_empty() == true);

                Ok::<(), eyre::Error>(())
            }).await;

            println!("inside modulespawn");
            e.unwrap();
        }

        //////////////////////////////////////////////////////////////

        /*
        // this one does not work
        // this is because it can't progress past the bystream loop.
        #[tokio::test]
        // Talking over ServiceSpawn's bytestreams as the client while spawning a server module
        async fn test_module_creation_client_with_bytestreams() {
            let spawn_process_server = UnixProcessServiceSpawnImpl();
            let spawn_process_client: UnixProcessServiceSpawnClient = capnp_rpc::new_client(spawn_process_server);

            let e = task::LocalSet::new().run_until(async {
                println!("modulespawn start");
                let mut read_wrapper = ReadWrapper {
                    buffer: Arc::new(Mutex::new(Vec::new())),
                };

                let buffer = read_wrapper.buffer.clone();
                let stdout_server = ByteStreamImpl::new(move |bytes| {
                    let mut guard = buffer.lock().unwrap();
                    guard.extend_from_slice(bytes);
                    match std::str::from_utf8(bytes) {
                        Ok(value) => {
                            println!("remote stdout: {}", value);
                        },
                        Err(e) => {
                            println!("remote stdout got utf8 unprintable bytes and thus an error: {:?}", e);
                        }
                    }
                    Promise::ok(())
                });
                let stdout_client = capnp_rpc::new_client(stdout_server);
                let stderr_server = ByteStreamImpl::new(|bytes| {
                    println!("remote stderr: {}", std::str::from_utf8(bytes).unwrap());
                    Promise::ok(())
                });
                let stderr_client = capnp_rpc::new_client(stderr_server);

                let process_client = spawn_process_client.request_spawn_process(
                    "../target/debug/keystone-hello-world-module",
                    &["server"],
                    stdout_client,
                    stderr_client).await?;

                let (write_sender, mut write_receiver) = mpsc::channel::<Vec<u8>>(32);
                let mut write_wrapper = WriteWrapper {
                    write_sender: write_sender,
                };
                let hello_world_client: hello_world::Client = capnp_rpc::new_client(HelloWorldImpl);

                let reader = tokio_util::compat::TokioAsyncReadCompatExt::compat(read_wrapper);
                let writer = tokio_util::compat::TokioAsyncWriteCompatExt::compat_write(write_wrapper);
                let network = twoparty::VatNetwork::new(
                    reader,
                    writer,
                    rpc_twoparty_capnp::Side::Client,
                    Default::default(),
                );

                let mut rpc_system = RpcSystem::new(Box::new(network), None);
                let hello_world: hello_world::Client = rpc_system.bootstrap(rpc_twoparty_capnp::Side::Server);

                tokio::task::spawn_local(rpc_system);
                println!("spawned rpc");

                let api_response = process_client.getapi_request().send().promise.await?;
                let api_reader = api_response.get()?.get_api()?;
                let stdin_server = api_reader.get_stdin()?;

                println!("looping");
                while let Some(data) = write_receiver.recv().await {
                    let _ = stdin_server.write_bytes(&data).await;
                }
                println!("can never reach this");

                // client specific code
                let mut request = hello_world.say_hello_request();
                request.get().init_request().set_name(msg[..].into());

                eprintln!("request constructed");
                let reply = request.send().promise.await?;
                eprintln!("reply sent and acquired: {}", reply.get()?.get_reply()?.get_message()?.to_str()?);
                //

                let geterror_response = process_client.geterror_request().send().promise.await?;
                let error_reader = geterror_response.get()?.get_result()?;

                let error_code = error_reader.get_error_code();
                assert_eq!(error_code, 0);

                let error_message = error_reader.get_error_message()?;
                assert!(error_message.is_empty() == true);

                Ok::<(), eyre::Error>(())
            }).await;

            println!("inside modulespawn");
            e.unwrap();
        }
        */


        //////////////////////////////////////////////////////////////

        /*
        // this one does not work
        // "called `Result::unwrap()` on an `Err` value: Failed: Too many segments: 1734439798"
        //  it gets too many segments for some reason.
        #[tokio::test]
        // Talking over ServiceSpawn's bytestreams as the client while spawning a server module
        async fn test_module_creation_client_with_no_bytestreams() {
            let e = task::LocalSet::new().run_until(async {
                println!("modulespawn start");

                let mut child = Command::new("../target/debug/keystone-hello-world-module")
                    .args(&["cargo", "run", "server"])
                    .stdout(std::process::Stdio::piped())
                    .stdin(std::process::Stdio::piped())
                    .spawn()?;

                let child_stdin = child.stdin.take().expect("Failed to open child stdin");
                let child_stdout = child.stdout.take().expect("Failed to open child stdout");

                let reader = tokio_util::compat::TokioAsyncReadCompatExt::compat(child_stdout);
                let writer = tokio_util::compat::TokioAsyncWriteCompatExt::compat_write(child_stdin);

                let network = twoparty::VatNetwork::new(
                    reader,
                    writer,
                    rpc_twoparty_capnp::Side::Client,
                    Default::default(),
                );

                let mut rpc_system = RpcSystem::new(Box::new(network), None);
                let hello_world: hello_world::Client = rpc_system.bootstrap(rpc_twoparty_capnp::Side::Server);

                tokio::task::spawn_local(rpc_system);
                println!("spawned rpc");

                // client specific code
                let msg = "test";
                let mut request = hello_world.say_hello_request();
                request.get().init_request().set_name(msg[..].into());

                eprintln!("request constructed");
                let reply = request.send().promise.await?;
                eprintln!("reply sent and acquired: {:?}", reply.get()?.get_reply()?.get_message());//?.to_str()?);
                //

                Ok::<(), eyre::Error>(())
            }).await;

            println!("inside modulespawn");
            e.unwrap();
        }
        */
    }
}
